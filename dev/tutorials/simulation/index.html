<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Run a simulation · HallThruster.jl</title><meta name="title" content="Run a simulation · HallThruster.jl"/><meta property="og:title" content="Run a simulation · HallThruster.jl"/><meta property="twitter:title" content="Run a simulation · HallThruster.jl"/><meta name="description" content="Documentation for HallThruster.jl."/><meta property="og:description" content="Documentation for HallThruster.jl."/><meta property="twitter:description" content="Documentation for HallThruster.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citation.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="HallThruster.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">HallThruster.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Overview</a></li><li><a class="tocitem" href="../../NEWS/">Release notes</a></li><li><a class="tocitem" href="../../highlights/">Science highlights</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Run a simulation</a><ul class="internal"><li><a class="tocitem" href="#Install"><span>Install</span></a></li><li><a class="tocitem" href="#Configure"><span>Configure</span></a></li><li><a class="tocitem" href="#Run"><span>Run</span></a></li><li class="toplevel"><a class="tocitem" href="#Analyze"><span>Analyze</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/json/">Use JSON input and output</a></li><li><a class="tocitem" href="../../howto/python/">Run a simulation from python</a></li><li><a class="tocitem" href="../../howto/new_propellant/">Add a new propellant</a></li><li><a class="tocitem" href="../../howto/new_anom_model/">Implement an anomalous transport model</a></li><li><a class="tocitem" href="../../howto/coupling/">Couple HallThruster.jl to C or Fortran</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/physics/">Physics model</a></li><li><a class="tocitem" href="../../explanation/numerics/">Numerics</a></li><li><a class="tocitem" href="../../explanation/grid_generation/">Grid generation</a></li><li><a class="tocitem" href="../../explanation/timestepping/">Timestepping</a></li><li><a class="tocitem" href="../../explanation/verification/">Validation and verification</a></li><li><a class="tocitem" href="../../explanation/initialization/">Initialization</a></li><li><a class="tocitem" href="../../explanation/plume/">Quasi-1D plume model</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/config/">Configuration</a></li><li><a class="tocitem" href="../../reference/simparams/">Simulation parameters</a></li><li><a class="tocitem" href="../../reference/solution/">Solution</a></li><li><a class="tocitem" href="../../reference/postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../../reference/thrusters/">Thrusters</a></li><li><a class="tocitem" href="../../reference/propellants/">Propellants</a></li><li><a class="tocitem" href="../../reference/anomalous_transport/">Anomalous transport models</a></li><li><a class="tocitem" href="../../reference/wall_loss_models/">Wall loss models</a></li><li><a class="tocitem" href="../../reference/electron_thermal_conductivity/">Thermal conductivity models</a></li><li><a class="tocitem" href="../../reference/collisions/">Collisions and reactions</a></li><li><a class="tocitem" href="../../reference/internals/">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Run a simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Run a simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/UM-PEPL/HallThruster.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/UM-PEPL/HallThruster.jl/blob/main/docs/src/tutorials/simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-a-simulation"><a class="docs-heading-anchor" href="#Running-a-simulation">Running a simulation</a><a id="Running-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-a-simulation" title="Permalink"></a></h1><p>In this tutorial, we will take you through running a simulation of an SPT-100 Hall thruster in <code>HallThruster</code>. Along the way, you will learn how to</p><ul><li>install the <code>HallThruster</code> package</li><li>configure simulation options </li><li>run a simulation</li><li>examine the results</li></ul><p>We assume that you have a basic familiarity with the Julia programming language, and have installed Julia following the instructions on the <a href="https://github.com/JuliaLang/juliaup">Julia website</a>. If this does not apply to you, you will want to familiarize yourself with Julia using the <a href="https://docs.julialang.org/en/v1/manual/getting-started/">Getting started</a> section of the Julia manual. We also assume you know what a Hall thruster is and have some understanding of their operation.</p><h2 id="Install"><a class="docs-heading-anchor" href="#Install">Install</a><a id="Install-1"></a><a class="docs-heading-anchor-permalink" href="#Install" title="Permalink"></a></h2><p>First, open Julia and type &#39;]&#39; to enter the Package REPL (<strong>R</strong>ead-<strong>E</strong>valuate-<strong>P</strong>rint <strong>L</strong>oop) You should see the following prompt (the version may differ depending on your default Julia version).</p><pre><code class="language-julia hljs">(@v1.10) pkg&gt;</code></pre><p>To install <code>HallThruster</code> io your global environment, simply type </p><pre><code class="language-julia hljs">(@v1.10) pkg&gt; add HallThruster</code></pre><p>This will download and precompile <code>HallThruster</code> and all of its dependencies. This works, but it is not always desirable to install packages to your global environment. Instead, it is common to have different packages loaded depending on your specific project. To do this, first create a new folder, which we&#39;ll call <code>hallthruster_tutorial</code>. Change directories into this folder, open Julia, and enter the package REPL. Type </p><pre><code class="language-julia hljs">(@v1.10) pkg&gt; activate .</code></pre><p>to activate <code>hallthruster_tutorial</code> as its own environment. You should see <code>v1.10</code> (or whatever version) be replaced with the name of your current folder. From there, you can install packages as normal, i.e.</p><pre><code class="language-julia hljs">(hallthruster_tutorial) pkg&gt; add HallThruster</code></pre><p>This will create a file called <code>Project.toml</code>, which tracks the dependencies of the current environment. Environments are great for ensuring reproducability and portability of your Julia code. For example, if you want to send a script to a friend, sending the <code>Project.toml</code> file of your environment means they will be able to automatically download all of the packages you used in your script. Using one environment per project instead of the global environemnt means that your friend doesn&#39;t also have to download every single other package you happened to have installed, or manually install all of the packages you use in your script.</p><p>Once <code>HallThruster</code> has been installed, we&#39;re ready to begin writing and running our simulation code. Create a new file, perhaps called <code>hallthruster_tutorial.jl</code> and open it in your favorite text editor.</p><h2 id="Configure"><a class="docs-heading-anchor" href="#Configure">Configure</a><a id="Configure-1"></a><a class="docs-heading-anchor-permalink" href="#Configure" title="Permalink"></a></h2><p>The first thing we need to do is tell your script that we want to use <code>HallThruster</code>. To do this, add the following to the beginning of your script.</p><pre><code class="language-julia hljs">using HallThruster: HallThruster as het</code></pre><p>This tells Julia that you want access to the <code>HallThruster</code> module. Since we will be accessing a lot of code in <code>HallThruster</code>, we also tell Julia that we want to refer to <code>HallThruster</code> as a shorter name, in this case <code>het</code> for <strong>H</strong>all-<strong>e</strong>ffect <strong>t</strong>hruster. You can leave this out, or change <code>het</code> to whatever you want.</p><p>We need to tell <code>HallThruster</code> about what kind of simulation we want to run. This is the job of a <a href="../../reference/config/#HallThruster.Config"><code>Config</code></a>. A <code>Config</code> struct contains most of the geometric, physical, and numerical information that HallThruster.jl needs in order to simulate a Hall thruster. There are a lot of options in a <code>Config</code>, but we will only use a few of them in this tutorial. You can read a full listing of these parameters, their effects, and their defaults on the <a href="../../reference/config/">Configuration</a> page.</p><p>Only four parameters are absolutely <em>required</em> in a <code>Config</code>. These are</p><ol><li>the thruster we want to simulate,</li><li>the discharge voltage,</li><li>the neutral mass flow rate at the anode,</li><li>the size of the simulation domain.</li></ol><p>We&#39;ll begin by constructing a <a href="../../reference/thrusters/#HallThruster.Thruster"><code>Thruster</code></a> A <code>Thruster</code> has four components – a name, a geometry, a magnetic field, and an optional flag that says whether the thruster is magnetically-shielded. The geometry is defined using a <a href="../../reference/thrusters/#HallThruster.Geometry1D"><code>Geometry1D</code></a> struct, which requires to specify the length of the discharge channel in combination with the inner and outer channel radii. For the SPT-100, a <code>Geometry1D</code> can be constructed like so:</p><pre><code class="language-julia hljs">using HallThruster: HallThruster as het

# All units are SI unless explicitly specified
geom = het.Geometry1D(
    channel_length = 0.025,
    inner_radius = 0.0345,
    outer_radius = 0.05,
)</code></pre><p>Note that all units are SI unless a unit is explicitly listed in the parameter name. As a result, <code>Geometry1D</code> expects dimensions in meters. If you would like to use explicit units, you can install and load either <a href="https://github.com/PainterQubits/Unitful.jl"><code>Unitful</code></a> or <a href="https://github.com/SymbolicML/DynamicQuantities.jl"><code>DynamicQuantities</code></a>, and specify dimensions as follows</p><pre><code class="language-julia hljs">using HallThruster: HallThruster as het
using Unitful # or `using DynamicQuantities`, if desired

geom = het.Geometry1D(
    channel_length = 2.5u&quot;cm&quot;,
    inner_radius = 34.5u&quot;mm&quot;,
    outer_radius = 0.05u&quot;m&quot;,
)</code></pre><p>With the <code>Geometry1D</code> object constructed, we can turn to specifying the radial magnetic field. Unsurprisingly, we use a <a href="../../reference/thrusters/#HallThruster.MagneticField"><code>MagneticField</code></a> struct for this. <code>MagneticField</code> has three fields — a filename and two arrays. The first array (<code>z</code>) specifies the axial coordinates (in meters) at which the magnetic field is known. The second (<code>B</code>) provides the magnetic field (in Tesla) at those points. While we can definitely manually pass these to <code>MagneticField</code>, in most cases you will want to pass a file instead. You can download a sample magnetic field file <a href="https://github.com/UM-PEPL/HallThruster.jl/blob/v1.0/test/json/bfield_spt100.csv">here</a>.</p><p>Once you have downloaded the magnetic field file and placed it in your current working directory, you can load it using the <a href="../../reference/thrusters/#HallThruster.load_magnetic_field"><code>load_magnetic_field</code></a> function.</p><pre><code class="language-julia hljs">bfield = het.load_magnetic_field(&quot;bfield_spt100.csv&quot;)</code></pre><p>If the magnetic field is in some other directory, you can tell <code>load_magnetic_field</code> to look for it using the <code>include_dirs</code> argument.  <code>HallThruster</code> will check the provided directories before looking in the present working directory.</p><pre><code class="language-julia hljs">bfield = het.load_magnetic_field(
    &quot;bfield_spt100.csv&quot;; 
    include_dirs = [&quot;/some/directory&quot;, &quot;/another/directory&quot;]
)</code></pre><p>With our geometry and magnetic field specified, we can finally create a <code>Thruster</code>.</p><pre><code class="language-julia hljs">thruster = het.Thruster(
    name = &quot;SPT-100&quot;,
    geometry = geom,
    magnetic_field = bfield
)</code></pre><p>Now, we can set the rest of the options in <code>Config</code>. We&#39;ll use a discharge voltage of 300 V, a mass flow rate of 5 milligrams per second, and a domain length of 8 cm. We will also explicitly specify that the propellant is xenon and specify the mass flow rate and a maximum charge state of one. Note that multiple propellants can be provided, so we can run the thruster on propellant mixtures.</p><pre><code class="language-julia hljs">config = het.Config(
    thruster = thruster,
    domain = (0.0, 0.08),
    discharge_voltage = 300.0,
    propellants = [het.Propellant(het.Xenon, flow_rate_kg_s = 5e-6, max_charge=1)],
)</code></pre><p>As with <code>Geometry1D</code>, units may be provided here using <code>Unitful</code> or <code>DynamicQuantities</code>, e.g</p><pre><code class="language-julia hljs">using Unitful

config = het.Config(
    thruster = thruster,
    domain = (0.0u&quot;cm&quot;, 8.0u&quot;cm&quot;),
    discharge_voltage = 300.0u&quot;V&quot;,
    propellants = [het.Propellant(het.Xenon, flow_rate_kg_s = 5u&quot;mg/s&quot;, max_charge=1)],
)</code></pre><h2 id="Run"><a class="docs-heading-anchor" href="#Run">Run</a><a id="Run-1"></a><a class="docs-heading-anchor-permalink" href="#Run" title="Permalink"></a></h2><p>Now that we have created a <code>Config</code> struct, we can run our simulation. You might notice that we did not specify a timestep or a grid at any point. To do this, we make use of the <a href="../../reference/simparams/#HallThruster.SimParams"><code>SimParams</code></a> struct.</p><pre><code class="language-julia hljs">simparams = het.SimParams(
    grid = het.EvenGrid(100),   # an evenly-spaced grid with 100 cells
    dt = 5e-9,                  # a base timestep of 5 nanoseconds
    duration = 1e-3,            # run the simulation for one millisecond of simulated time
    num_save = 1000,            # save 1000 frames of output
)</code></pre><p>Here, we specified only four parameters, but <code>SimParams</code> has many more options that can be configured. See the page on <a href="../../reference/simparams/">Simulations</a> for more details. These four are:</p><ul><li>The <code>grid</code>, which we have set to an <code>EvenGrid</code> with 100 cells. We can alternatively use an <code>UnevenGrid</code>, which provides more resolution near the discharge channel and less in the plume. More information about these grids can be found on the <a href="../../explanation/grid_generation/">Grid generation</a> page.</li><li>The base timestep <code>dt</code>, in seconds. HallThruster uses adaptive timestepping by default, so typical timesteps will differ from the value provided here, but the base timestep is used in certain cases when the adaptive timestepping scheme gets stuck, or when uniform timestepping is explicitly requested (by passing <code>adaptive=false</code> to the <code>SimParams</code> struct). We give more detailed explanation of <code>HallThruster</code>&#39;s timestepping strategy on the <a href="../../explanation/timestepping/">Timestepping</a> page.</li><li>The simulation <code>duration</code>, in seconds.</li><li>The number of frames we wish to save over the simulation runtime. Each frame captures the state of the simulation at a specific time. These are evenly spaced across <code>duration</code>.</li></ul><p>As always, units may be specified.</p><pre><code class="language-julia hljs">simparams = het.SimParams(
    grid = het.EvenGrid(100),   # an evenly-spaced grid with 100 cells
    dt = 5u&quot;ns&quot;,                # a base timestep of 5 nanoseconds
    duration = 1u&quot;ms&quot;,          # run the simulation for one millisecond of simulated time
    num_save = 1000,            # save 1000 frames of output
)</code></pre><p>Finally, we can pass these to the <a href="../../reference/simparams/#HallThruster.run_simulation-Tuple{HallThruster.Config, HallThruster.SimParams}"><code>run_simulation</code></a> function, which runs the simulation and returns a <a href="../../reference/solution/#HallThruster.Solution"><code>Solution</code></a> object.</p><pre><code class="language-julia hljs">solution = het.run_simulation(config, simparams)

# output

[ Info: Simulation exited at t = 0.001 with retcode :success in 1.025520708 seconds.
Hall thruster solution with 1000 saved frames (retcode: success, end time: 0.001 seconds)</code></pre><p>The first line is printed when a simulation is completed (unless <code>simparams.verbose = false</code>) and tells us the run-time of our simulation. The second line provides a summary of the Hall thruster solution in question, telling us that the simulation has 1000 saved frames, that its end time is 1 ms (0.001 seconds), and, most importantly, that it succeeded (the return code or <code>retcode</code> is <code>:success</code>). If something goes wrong, the simulation will terminate early and the return code will be either <code>failure</code> or <code>error</code>. A return code of <code>:failure</code> means the simulation became unstable and blew up and a <code>NaN</code> or <code>Inf</code> was detected, while a return code of <code>:error</code> means some other error occurred.</p><h1 id="Analyze"><a class="docs-heading-anchor" href="#Analyze">Analyze</a><a id="Analyze-1"></a><a class="docs-heading-anchor-permalink" href="#Analyze" title="Permalink"></a></h1><h3 id="The-Solution-object"><a class="docs-heading-anchor" href="#The-Solution-object">The Solution object</a><a id="The-Solution-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-Solution-object" title="Permalink"></a></h3><p>The <a href="../../reference/solution/#HallThruster.Solution"><code>Solution</code></a> object is made up of a few fields. These are </p><ul><li><code>retcode</code>: The return code, described above.</li><li><code>t</code>: A <code>Vector</code> of times at which the simulation state is saved. The length of the vector is <code>SimParams.num_save</code></li><li><code>frames</code>: A <code>Vector</code> of <code>NamedTuple</code>s containing plasma properties at each of the times in <code>t</code>. The length of the vector is <code>SimParams.num_save</code></li><li><code>grid</code>: A <code>Grid</code> object containing the cell and edge locations for the simulation</li><li><code>config</code>: the <code>Config</code> we ran the simulation with</li><li><code>simulation</code>: the <code>SimParams</code> we ran the simulation with</li><li><code>postprocessing</code>: the <code>Postprocessing</code> object we used, if we used one.</li><li><code>error</code>: A string containing any errors that occurred, along with traceback information. This is empty if <code>retcode</code> is not <code>:error</code></li></ul><p>We can extract some useful global metrics from a solution, like thrust, discharge<em>current, and anode</em>efficiency.</p><pre><code class="language-julia hljs">thrust = het.thrust(solution)
discharge_current = het.discharge_current(solution)
anode_eff = het.anode_eff(solution)</code></pre><p>These functions return a vector of thrusts or discharge currents at each of the times in <code>solution.t</code>. There are serveral other functions that act analogously, computing efficiencies or other global metrics. A full listing of these can be found on the <a href="../../reference/postprocessing/">Postprocessing</a> page.</p><p>Below, we use <a href="https://docs.makie.org/stable/">Makie</a> to plot the discharge current over time for this specific simulation. We can see that the simulation begins with strong transient oscillations before settling down to a relatively stable steady state.</p><pre><code class="language-julia hljs">using CairoMakie: Makie as mk

current = het.discharge_current(solution)
f, ax, _ = mk.lines(
    solution.t .* 1e6, current, 
    figure = (;
        size = (800, 300)
    ),
    axis = (
        xlabel = &quot;Time [microseconds]&quot;,
        ylabel = &quot;Discharge current [A]&quot;,
    )
)</code></pre><p><img src="../../assets/tutorial_id.svg" alt/></p><h3 id="Average"><a class="docs-heading-anchor" href="#Average">Average</a><a id="Average-1"></a><a class="docs-heading-anchor-permalink" href="#Average" title="Permalink"></a></h3><p>If you want a time-averaged global metric, you could average one of these vectors yourself, or you could let <code>HallThruster</code> do it for you. For this purpose, <code>HallThruster</code> provides the <a href="../../reference/postprocessing/#HallThruster.time_average-Tuple{HallThruster.Solution, Any}"><code>time_average</code></a> function, which averages an entire <code>Solution</code> object.</p><pre><code class="language-julia hljs">avg = het.time_average(solution)

# output

Hall thruster solution with 1 saved frame (retcode: success, end time: 0.001 seconds)</code></pre><p>The result of the time-averaging operation is a new <code>Solution</code> object containing a single frame. All of the normal functions that operate on <code>Solution</code> objects, like <code>discharge_current</code>, still work on a time-averaged <code>Solution</code>. This averaging can be partial—you can specify a frame index or time from which the averaging begins</p><pre><code class="language-julia hljs">avg = het.time_average(solution, 300)       # average starting at frame 300
avg = het.time_average(solution, 5e-4)      # average starting at 5e-4 seconds
avg = het.time_average(solution, 0.5u&quot;ms&quot;)  # units are supported too, if Unitful or DynamicQuantities loaded</code></pre><p>You can also index a <code>Solution</code> with an integer or range to extract a specific frame or range of frames, e.g.</p><pre><code class="language-julia hljs">tenth_frame = solution[10]      # extract frame number 10 as a new Solution object
middle_800 = solution[101:900]  # extract frames 101:900
avg_middle = het.time_average(solution[350:750])    # average frames 350 to 750</code></pre><p>Postprocessing functions like <code>discharge_current</code> and <code>thrust</code> work normally on the results of these operations as well.</p><h3 id="Extract-plasma-properties"><a class="docs-heading-anchor" href="#Extract-plasma-properties">Extract plasma properties</a><a id="Extract-plasma-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Extract-plasma-properties" title="Permalink"></a></h3><p>Lastly, we can obtain plasma properties by indexing a <code>Solution</code> object with a <code>Symbol</code>. For instance, if we want to extract the time-averaged ion velocity of singly-charged ions, we could do</p><pre><code class="language-julia hljs">avg = het.time_average(solution, 0.5u&quot;ms&quot;)
ui_1 = avg.frames[].ions[:Xe][1].u</code></pre><p>Here, we use <code>:Xe</code> to specify which ion type we want and <code>1</code> indicates that we want singly-charged ions. Electron properties can be obtained directly from the frame, as shown below.</p><pre><code class="language-julia hljs">Te = avg.frames[].Tev   # electron temp in eV
E = avg.frames[].E      # electric field in V/m</code></pre><p>We can plot the extracted properties using a plotting package like <a href="https://docs.makie.org/stable/">Makie</a>.</p><pre><code class="language-julia hljs">using CairoMakie: Makie as mk

avg = het.time_average(solution, 0.5u&quot;ms&quot;)

# extract the cell centers in meters, and multiply to convert to cm
z_cm = avg.grid.cell_centers .* 100

# extract the ion velocity and convert to km/s
ui_km_s = avg.frames[].ions[:Xe][1].u ./ 1000

f, ax, ln = mk.lines(
    z_cm, ui_km_s,
    axis = (
        xlabel = &quot;Axial coordinate [cm]&quot;,
        ylabel = &quot;Ion velocity [km]&quot;)
)

display(f)</code></pre><p><img src="../../assets/tutorial_ui.svg" alt/></p><p>Many other parameters can be extracted this way, including neutral and electron properties. See <a href="../../reference/solution/#Outputs">Outputs</a> for a full list.</p><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>Now you known how to run a basic simulation in <code>HallThruster</code>. You can specify a thruster and geometry, input operating conditions, select numerical properties, run the simulation, and extract useful data. In this tutorial, we left many of the options at their defaults, but <code>HallThruster</code> is highly configurable. You can change <a href="../../reference/anomalous_transport/">anomalous transport models</a>, <a href="../../reference/propellants/">propellants</a>, <a href="../../reference/wall_loss_models/">wall loss models</a>, and more. If none of the built-ins are sufficient, you can even <a href="../../howto/new_anom_model/">write your own models</a> and <a href="../../howto/new_propellant/">create your own propellants</a>. You can also <a href="../../howto/python/">run the code from python</a>, or <a href="../../howto/json/">directly from a JSON input file</a>. The rest of the documentation contains details about all of this and more.</p><p>If you encounter an issue running the code, please file a <a href="https://github.com/UM-PEPL/HallThruster.jl/issues">GitHub issue</a>. <code>HallThruster</code> is an evolving code, and new features are implemented on a regular basis. Requests for features and documentation improvement are also welcome, though we cannot guarantee that any specific features will be implemented.</p><p>Happy simulating!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../highlights/">« Science highlights</a><a class="docs-footer-nextpage" href="../../howto/json/">Use JSON input and output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 16 October 2025 19:28">Thursday 16 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
