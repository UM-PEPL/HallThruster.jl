var documenterSearchIndex = {"docs":
[{"location":"reference/electron_thermal_conductivity/#Electron-Thermal-Conductivity","page":"Thermal conductivity models","title":"Electron Thermal Conductivity","text":"","category":"section"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"HallThruster has a few electron thermal conductivity models built in and allows users to define their own. This page describes these models and the process by which algebraic transport models can be added by the user.","category":"page"},{"location":"reference/electron_thermal_conductivity/#Built-in-Models","page":"Thermal conductivity models","title":"Built-in Models","text":"","category":"section"},{"location":"reference/electron_thermal_conductivity/#Mitchner()","page":"Thermal conductivity models","title":"Mitchner()","text":"","category":"section"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"HallThruster.jl's default electron thermal conductivity option. This model employs the form described in Mitchner & Kruger \"Partially Ionized Gases\" (1973). The thermal conductivity takes the form:","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"beginaligned\n    kappa_eperp  approx frac11+Omega_H^2 frac241+ fracnu_iesqrt2nu fracneTe (eV)nu m_e \n    nu = nu_ei + nu_en + nu_AN \nendaligned","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"The model is initialized by default but can be explicitly enabled by including:","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"conductivity_model = Mitchner()","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"In the user-defined configuration","category":"page"},{"location":"reference/electron_thermal_conductivity/#Braginskii()","page":"Thermal conductivity models","title":"Braginskii()","text":"","category":"section"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"This form of the thermal conductivity follows the result of S. I. Braginskii, in Reviews of Plasma Physics, edited by M. A. Leontovich (Consultants Bureau, New York, 1965), Vol. 1, p. 205.:","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"\\begin{aligned}     \\kappa{e\\perp} & \\approx C \\frac{neTe (eV) \\nu}{me \\omega{ce}^2} \\\n    \\nu = \\nu{ei} + \\nu{en} + \\nu{AN} \\\n\\end{aligned}","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"Where C is a constant that is based on the value of the effective charge for multiple charge states and Table 1 of the Braginskii reference. A Braginskii model can be initialized in the user-defined configuration as:","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"conductivity_model = Braginskii()","category":"page"},{"location":"reference/electron_thermal_conductivity/#Custom-thermal-conductivity-models","page":"Thermal conductivity models","title":"Custom thermal conductivity models","text":"","category":"section"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"The procedure for adding additional thermal conductivity models generally follows that of adding anomalous transport models, as described on the Anomalous transport page. The two main differences is that the model type is of 'ThermalConductivityModel' rather than 'AnomalousTransportModel' and that the function needs to return kappa rather than nu an. For demonstration pursposes however, let's say we wanted to implement the Braginskii model but without the anomalous collision frequency and a coefficient of 4.66 (singly charged ions only). We first define the type:","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"using HallThruster\n\nstruct Braginskii_Classical <: ThermalConductivityModel end","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"With the type defined, we then need to define the function that describes the model. This function should take two arguements, the vector of thermal conductivity values and the solver params.","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"function (model::Braginskii_Classical)(κ, params)\n\n    me = HallThruster.me\n    e = HallThruster.e\n    B = params.cache.B\n    ne = params.cache.ne\n    Te = params.cache.Tev\n\n    for i in eachindex(κ)\n        ωce = e * B[i] / me\n        κ[i] = 4.66 * ne * e * Te * params.cache.νc[i] / (me * ωce^2)\n    end\n\n    return κ\nend","category":"page"},{"location":"reference/electron_thermal_conductivity/","page":"Thermal conductivity models","title":"Thermal conductivity models","text":"We could now employ this model by setting `conductivitymodel = BraginskiiClassical()' in the user-defined configuration. ","category":"page"},{"location":"howto/python/#Run-a-simulation-from-python","page":"Run a simulation from python","title":"Run a simulation from python","text":"","category":"section"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"CurrentModule = HallThruster","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"HallThruster comes bundled with a script that enables users to run simulations from python. To use this script, you will first need to install HallThruster as described in the home page or  tutorial.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"Next, launch Julia and activate the environment in which you have installed HallThruster. Check HallThruster.PYTHON_PATH to see the absolute path to the python script on your machine.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"PYTHON_PATH","category":"page"},{"location":"howto/python/#HallThruster.PYTHON_PATH","page":"Run a simulation from python","title":"HallThruster.PYTHON_PATH","text":"The absolute path to the HallThruster python code on your machine.\n\njulia> using HallThruster; HallThruster.PYTHON_PATH\n\"/Users/archermarks/src/HallThruster/python\"\n\n\n\n\n\n","category":"constant"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"Next, open a python script and import the path returned by python_script_path().","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"import sys\n\nsys.path.append(\"/Users/archermarks/src/HallThruster/python\")\n\nimport hallthruster as het","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"With HallThruster imported, you can create the inputs to your simulation. These are exactly identical to those used for the JSON interface, so we will not belabor them here. You can either use a dictionary or a path to a JSON file.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"As in the Julia version, we first create a config dict to hold geometric and plasma properties.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"config = {\n    \"thruster\": {\n        \"name\": \"SPT-100\",\n        \"geometry\": {\n            \"channel_length\": 0.025,\n            \"inner_radius\": 0.0345,\n            \"outer_radius\": 0.05,\n        },\n        \"magnetic_field\": {\n            \"file\": \"bfield_spt100.csv\"\n        }\n    },\n    \"discharge_voltage\": 300.0,\n    \"anode_mass_flow_rate\": 5e-6,\n    \"domain\": (0.0, 0.08),\n    \"anom_model\": {\n        \"type\": \"TwoZoneBohm\",\n        \"c1\": 0.00625,\n        \"c2\": 0.0625,\n    },\n    \"ncharge\": 3\n}","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"Next, we create a simulation dict to hold timestepping properties.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"simulation = {\n    \"dt\": 5e-9,\n    \"adaptive\": True,\n    \"grid\": {\n        \"type\": \"EvenGrid\",\n        \"num_cells\": 100,\n    },\n    \"num_save\": 100,\n    \"duration\": 1e-3,\n}","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"Lastly, we create a postprocess dict to hold the output file and desired output format.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"postprocess = {\n    \"output_file\": \"output.json\",\n    \"save_time_resolved\": False,\n    \"average_start_time\": 5e-4,\n}","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"With these created, we can run our simulation. Note that if we already have a JSON file with these inputs, we can pass the json path instead of the dictionary.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"input = {\"config\": config, \"simulation\": simulation, \"postprocess\": postprocess}\n\nsolution = het.run_simulation(input, jl_env = \".\")","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"Here, we have provided the keyword argument jl_env to tell Python where it should look for HallThruster. This should be the directory in which you have a Project.toml specifying HallThruster as a dependency. If left blank, the script will assume that you want to use the global environment.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"The run_simulation function will return a solution output prepared according to postprocess. If postprocess.output_file is not blank, the solution will also be written to the specified file in addition to being returned from the function.","category":"page"},{"location":"howto/python/#Extracting-results","page":"Run a simulation from python","title":"Extracting results","text":"","category":"section"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"We can call solution.keys to examine the output.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":">>> solution.keys()\ndict_keys(['input', 'output'])","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"As in the JSON interface, we duplicate the inputs used to run the simulation into input, and put the results of the simulation in output.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":">>> solution['input'].keys()\ndict_keys(['config', 'simulation', 'postprocess'])\n\n>>> solution['output'].keys()\ndict_keys(['retcode', 'error', 'average'])","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"If we had requested time-resolved output, output would have a frames field in addition to average. We will first want to examine the return code to see if the simulation completed successfully.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":">>> output = solution['output']\n>>> output['retcode']\n'success'","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"The simulation outputs can be examined and plotted similarly to the julia interface. The fields of each frame are as follows:","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":">>> output['average'].keys()\ndict_keys(['thrust', 'discharge_current', 'ion_current', 'mass_eff', 'voltage_eff', 'current_eff', 'divergence_eff', 'anode_eff', 't', 'z', 'nn', 'ni', 'ui', 'niui', 'B', 'ne', 'ue', 'potential', 'E', 'Tev', 'pe', 'grad_pe', 'nu_en', 'nu_ei', 'nu_anom', 'nu_class', 'mobility', 'channel_area'])","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"Here's an example showing how to analyze both ion and electron quantities.","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"import matplotlib.pyplot as plt\nimport numpy as np\n\nf, axes = plt.subplots(1, 2, figsize = (10,5))\nxlabel = 'Axial position [cm]'\naxes[0].set_xlabel(xlabel)\naxes[1].set_xlabel(xlabel)\naxes[0].set_ylabel('\\$u_i\\$ [km/s]')\naxes[1].set_ylabel('\\$T_e\\$ [eV]')\naxes[0].set_title('Ion velocity')\naxes[1].set_title('Electron temperature')\n\nconfig = solution['input']['config']\npropellant = config['propellant']\navg = solution['output']['average']\nz_cm = np.array(avg['z']) * 100\n\nfor Z in range(solution['input']['config']['ncharge']):\n    ui_km_s = np.array(avg['ui'][Z]) / 1000\n    axes[0].plot(z_cm, ui_km_s, label = f\"{propellant} {Z+1}+\")\n\naxes[1].plot(z_cm, avg['Tev'])\naxes[0].legend()\nplt.tight_layout()\n\nplt.show()","category":"page"},{"location":"howto/python/","page":"Run a simulation from python","title":"Run a simulation from python","text":"This produces the following plot: (Image: )","category":"page"},{"location":"explanation/plume/#Plume-model","page":"Quasi-1D plume model","title":"Plume model","text":"","category":"section"},{"location":"reference/anomalous_transport/#Anomalous-transport","page":"Anomalous transport models","title":"Anomalous transport","text":"","category":"section"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"HallThruster has a few anomalous transport models built in and allows users to define their own. This page describes these models and the process by which algebraic and multi-equation transport models can be added by the user.","category":"page"},{"location":"reference/anomalous_transport/#Built-in-Models","page":"Anomalous transport models","title":"Built-in Models","text":"","category":"section"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"NoAnom\nBohm\nTwoZoneBohm\nGaussianBohm\nMultiLogBohm\nLogisticPressureShift\nSimpleLogisticShift","category":"page"},{"location":"reference/anomalous_transport/#HallThruster.NoAnom","page":"Anomalous transport models","title":"HallThruster.NoAnom","text":"NoAnom <: AnomalousTransportModel\n\nNo anomalous collision frequency included in simulation\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#HallThruster.Bohm","page":"Anomalous transport models","title":"HallThruster.Bohm","text":"Bohm(c) <: AnomalousTransportModel\n\nModel where the anomalous collision frequency scales with the electron cyclotron frequency ωce times some scaling factor c\n\nFields\n\nc::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#HallThruster.TwoZoneBohm","page":"Anomalous transport models","title":"HallThruster.TwoZoneBohm","text":"TwoZoneBohm(c1, c2) <: AnomalousTransportModel\n\nModel where the anomalous collision frequency has two values: c1 * ωce inside the channel and c2 * ωce outside of the channel. Takes two arguments: c1 and c2. The transition between these values is smoothed over config.transition_length.\n\nFields\n\nc1::Float64\nc2::Float64\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#HallThruster.GaussianBohm","page":"Anomalous transport models","title":"HallThruster.GaussianBohm","text":"GaussianBohm(hall_min, hall_max, center, width) <: AnomalousTransportModel\n\nModel in which the anomalous collision frequency is Bohm-like (νan ~ ω_ce),  except in a Gaussian-shaped region defined centered on z = center, where the collision frequency is lower.\n\nFields\n\nhall_min::Float64: the minimum Hall parameter\nhall_max::Float64: the maximum Hall parameter\ncenter::Float64: the axial position (in meters) of the mean of the Gaussian trough\nwidth::Float64: the standard deviation (in meters) of the Gaussian trough\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#HallThruster.MultiLogBohm","page":"Anomalous transport models","title":"HallThruster.MultiLogBohm","text":"MultiLogBohm(zs, cs) <: AnomalousTransportModel\n\nModel similar to that employed in Hall2De, where the mobility is Bohm-like (i.e. νan(z) = c(z) * ωce(z)) and z is in meters.\n\nThe function c(z) is defined by a sequence of nodes (z, c) provided by the user. At z = z[1], c(z) = c[1], and so forth.\n\nAt z[i] < z < z[i+1], log(c) is defined by linearly interpolating between log(c[i]) and log(c[i+1]).\n\nFor z < z[1], c = c[1] and for z > z[end], c(z) = c[end].\n\nThe user may also provide a single array of [z[1], z[2], ..., z[end], c[1], c[2], ..., c[end]]. The number of z values must be equal to the number of c values.\n\nFields\n\nzs::Vector{Float64}\ncs::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#HallThruster.LogisticPressureShift","page":"Anomalous transport models","title":"HallThruster.LogisticPressureShift","text":"LogisticPressureShift(model, z0, dz, pstar, alpha)\n\nA wrapper model that allows a transport profile to shift axially in response to changes in background pressure. The displacement/shift of the transport profile follows a logistic curve.\n\nFields\n\nmodel::HallThruster.AnomalousTransportModel: An anomalous transport model\n\nz0::Float64: the center of the shift at 0 background pressure\n\ndz::Float64: the total pressure shift across (0, Inf) background pressure\n\npstar::Float64: the \"turning point\" pressure\n\nalpha::Float64: the slope of the pressure-displacement response curve\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#HallThruster.SimpleLogisticShift","page":"Anomalous transport models","title":"HallThruster.SimpleLogisticShift","text":"SimpleLogisticShift(model, z0, dz, pstar, alpha)\n\nA wrapper model that allows a transport profile to shift axially in response to changes in background pressure.  As with LogisticPressureShift, the displacement/shift of the transport profile follows a logistic curve. However, the parameterization is different, so that the shift is zero when the background pressure is zero. As such, it does not have a z0 parameter.\n\nFields\n\nmodel::HallThruster.AnomalousTransportModel: An AnomalousTransportModel\n\nshift_length::Float64: The maximum displacement in response to increasing pressure, scaled by the discharge channel length. This should be positive.\n\nmidpoint_pressure::Float64: The pressure at the midpoint of the shift, in Torr. Defaults to 25e-6 Torr, which gives good fits for the H9 and SPT-100.\n\nslope::Float64: The slope of the pressure response curve. Defaults to 2, which gives good fits for the H9 and SPT-100.\n\n\n\n\n\n","category":"type"},{"location":"reference/anomalous_transport/#The-AnomalousTransportModel-interface","page":"Anomalous transport models","title":"The AnomalousTransportModel interface","text":"","category":"section"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"Users defining their own transport model will need first define a model that subtypes AnomalousTransportModel. They will then need to provide definitions for the following methods","category":"page"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"num_anom_variables","category":"page"},{"location":"reference/anomalous_transport/#HallThruster.num_anom_variables","page":"Anomalous transport models","title":"HallThruster.num_anom_variables","text":"num_anom_variables(::AnomalousTransportModel)::Int\n\nThe number of variable arrays that should be allocated for the provided anomalous transport model. These arrays are used to save state beyond the anomalous collision frequency, and are useful for defining more complex anomalous transport models. If not defined by the user, this defaults to zero.\n\n\n\n\n\n","category":"function"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"Additionally, they will need to define a function that allows the model to be called with the following arguments.","category":"page"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"# replace <:AnomalousTransportModel with ::MyModel, where MyModel is the name of your model.\n(model<:AnomalousTransportModel)(nu_an, params, config)","category":"page"},{"location":"reference/anomalous_transport/","page":"Anomalous transport models","title":"Anomalous transport models","text":"This function should operate in-place on nu_an. See Adding an anomalous transport model for a guide on implementing new models.","category":"page"},{"location":"reference/simparams/#Simulations","page":"Simulation parameters","title":"Simulations","text":"","category":"section"},{"location":"reference/simparams/","page":"Simulation parameters","title":"Simulation parameters","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/simparams/","page":"Simulation parameters","title":"Simulation parameters","text":"In HallThruster, parameters used in the running of a specific simulation, such as the grid resolution and timestepping properties, are controlled by the SimParams struct. Below are the fields of this struct. As in all parts of the code, dimensional quantities are SI unless explicitly noted, but units may be provided using Unitful or DynamicQuantities.","category":"page"},{"location":"reference/simparams/#Types","page":"Simulation parameters","title":"Types","text":"","category":"section"},{"location":"reference/simparams/","page":"Simulation parameters","title":"Simulation parameters","text":"SimParams{C <: CurrentController}","category":"page"},{"location":"reference/simparams/#HallThruster.SimParams","page":"Simulation parameters","title":"HallThruster.SimParams","text":"mutable struct SimParams{C<:HallThruster.CurrentController}\n\ngrid::HallThruster.GridSpec: A grid specifier, either HallThruster.EvenGrid(n) or HallThruster.UnevenGrid(n), where n is the desired number of cells. See Grid generation for more information.\n\ndt::Float64: The simulation base timestep in seconds. See Timestepping for more info.\n\nduration::Float64: The simulation duration in seconds.\n\nnum_save::Int64: How many simulation frames to save in the Solution struct. Default: 1000\n\nverbose::Bool: Whether information such as the simulation run-time is printed to console. Default: true\n\nprint_errors::Bool: Whether errors are printed to console in addition to being captured in the Solution struct. Default: true\n\nadaptive::Bool: Whether to use adaptive timestepping. See Timestepping for more info. Default: true\n\nCFL::Float64: The CFL number used in adaptive timestepping. Maximum is 0.799. Default: 0.799\n\nmin_dt::Float64: The minimum allowable timestep in adaptive timestepping, in seconds. Default: 1e-10\n\nmax_dt::Float64: The maximum allowable timestep in adaptive timestepping, in seconds. Default: 1e-7\n\nmax_small_steps::Int64: The maximum number of minimally-sized timesteps permitted in adaptive timestepping. Default: 100\n\ncurrent_control::HallThruster.CurrentController: Discharge current controller. Default: HallThruster.NoController()\n\n\n\n\n\n","category":"type"},{"location":"reference/simparams/","page":"Simulation parameters","title":"Simulation parameters","text":"Using a SimParams in combination with a suitable Config, we can use run_simulation to run a simulation. We can also run a simulation from an appropriately-formatted JSON file. See Use JSON for input and output for more information.","category":"page"},{"location":"reference/simparams/#Functions","page":"Simulation parameters","title":"Functions","text":"","category":"section"},{"location":"reference/simparams/","page":"Simulation parameters","title":"Simulation parameters","text":"run_simulation(config::Config, sim::SimParams; postprocess = nothing, restart::String = \"\", kwargs...)\nrun_simulation(json_file::String; restart::String = \"\")","category":"page"},{"location":"reference/simparams/#HallThruster.run_simulation-Tuple{HallThruster.Config, HallThruster.SimParams}","page":"Simulation parameters","title":"HallThruster.run_simulation","text":"run_simulation(\n    config::HallThruster.Config,\n    sim::HallThruster.SimParams;\n    postprocess,\n    restart,\n    kwargs...\n) -> HallThruster.Solution{_A, P, C} where {_A, P<:NamedTuple, C<:HallThruster.Config}\n\n\nRun a Hall thruster simulation using the provided Config and SimParams objects. Returns a Solution object.\n\nArguments\n\nconfig::Config: contains geometry, plasma properties, and numerical information about the simulation. See Configuration for more information.\nsim::SimParams: contains grid generation and timestepping information. See Simulations for more information.\npostprocess::Union{Postprocess, Nothing}: contains file to which output is to be written and specifies what kind of output to write. If nothing, no output is written to file. See Postprocessing for more information.\nrestart::String:An optional path to a JSON file containing plasma data. If non-empty, the solution will be restarted from that file.\n\n\n\n\n\n","category":"method"},{"location":"reference/simparams/#HallThruster.run_simulation-Tuple{String}","page":"Simulation parameters","title":"HallThruster.run_simulation","text":"run_simulation(\n    json_file::String;\n    restart\n) -> HallThruster.Solution{_A, P, C} where {_A, P<:NamedTuple, C<:HallThruster.Config}\n\n\nRun a simulation from a JSON input file. If postprocess is set in the JSON file and postprocess.output_file is non-empty, output will be written to postprocess.output_file. If restart is a JSON file, this function will also try to restart the simulation from that file. Returns a Solution object.\n\n\n\n\n\n","category":"method"},{"location":"explanation/timestepping/#Timestepping","page":"Timestepping","title":"Timestepping","text":"","category":"section"},{"location":"explanation/numerics/#Numerics","page":"Numerics","title":"Numerics","text":"","category":"section"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"As described in Configuration and Initialization different flux options are available in HyperbolicScheme. Timemarching for the heavy species is handled using a second order strong-stability preserving Runge-Kutta scheme (SSPRK22). The left hand side of the electron energy equation is integrated implicitly using a Crank Nicolson Adams Bashforth (CNAB) scheme. This enables larger timessteps due to the severe restrictions due to the electron heat flux.","category":"page"},{"location":"explanation/numerics/#Spatial-discretization-for-heavy-species","page":"Numerics","title":"Spatial discretization for heavy species","text":"","category":"section"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"Neutrals and ions are considered heavy species (compared to electrons). HallThruster.jl uses the finite volume method (FVM). FVM has the advantage that it is by definition conservative, which is a useful property when solving hyperbolic conservation laws such as the Euler equations. Currently, only the continuity equation is solved for the neutrals and the isothermal Euler equations for the ion species. Possibly, the full Euler equations will be added in the future, its implementation has been verified using the Sod Shock tube. The following provides and example of the control volume approach applied to the continuity equation.","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"int_i-frac12^i+frac12 fracpartial n_npartial t dz + int_i-frac12^i+frac12 fracpartial n_n u_npartial z dz = int_i-frac12^i+frac12 dotn_n  dz","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"The n_n u_n can be replaced by a generic flux term F(z) and generalized to any advection like equation. Treatment of the source term is described in Collisions and Reactions. Integration results in","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"hfracpartial n_npartial t + left(F__i+frac12 - F__i-frac12right) = h dotn_n","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"See Fluxes for the implemented fluxes, and possible limiters to be used in reconstruction to ensure a total variation diminishing scheme (TVD).","category":"page"},{"location":"explanation/numerics/#Time-discretization-of-heavy-species","page":"Numerics","title":"Time discretization of heavy species","text":"","category":"section"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"We employ a strong stability preserving second-order Runge Kutta scheme (SSPRK22) for timestepping","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"The user has the option to supply a fixed timestep, or a CFL number. In the former case, the user will need to select a timestep that obeys the CFL condition, defined as","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"    sigma = fracu_i Delta tDelta x  1","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"Using a maximum ion velocity of 22000 m/s, a domain length of 0.05m and 200 cells, results in Delta t leq 12 times 10^-8 s. In practice, it needs to be a bit lower in order to handle transients as the solution oscillates. This restriction is valid for the continuity and isothermal euler equations.","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"In most cases, it is better to let HallThruster.jl handle timestepping automatically using its adaptive timestepping option. If adaptive timestepping is enabled, the user-defined timestep is ignored in favor of a timestep based on the minimum of three conditions and a user-supplied CFL number. Mathematically the timstep is choosen as:","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"    Delta t = min(sigma fracDelta xmax(u_i + a_i u_i - a_i) sigma fracdotn_in_i sqrtfracsigma m_i Delta xq_i E)","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"Where a_i is the ion sound speed. Physically, these three conditions represent timestep limits imposed by the flux, ionization, and electrostatic acceleration. Keep in mind that due to stability limits imposed by the ionization condition, the CFL number cannot be higher than 0.799 to remain stable. This limit will be imposed by HallThruster.jl if the user-defined value is too high.","category":"page"},{"location":"explanation/numerics/#Electron-energy-equation-discretization","page":"Numerics","title":"Electron energy equation discretization","text":"","category":"section"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"While the ions can be explicitly solved with Delta t sim 10^-8s, the heat condution term in the electron energy equation adds additional constraints which would lower the timestep by about a factor of 10. In order to not further increase the timestepping restrictions and increase computation time, the electron energy equation is solved semi-implicitly in time using a backward Euler or Crank-Nicholson scheme. See Configuration for information on how to select which scheme is used.","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"The spatial discretization of the electron energy equation uses central finite differences in a manner similar to the potential solver (see below). This, combined with the semi-implicit timestepping, creates a tridiagonal linear system which can be efficiently solved using the Thomas algorithm.","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"If adaptive timestepping is enabled, the timestep used for the explicit terms is limited by:","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"    Delta t = absfrac3sigma n_eT_eW_loss + S_coll","category":"page"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"As this timestep may be significantly smaller than the timestep used for the heavy species, the electron energy equation is updated using a series of sub-steps with the Delta t enforced by the equation above until a total Delta t equal to that set by the heavy species is reached.","category":"page"},{"location":"explanation/numerics/#Evaluation-of-derivatives","page":"Numerics","title":"Evaluation of derivatives","text":"","category":"section"},{"location":"explanation/numerics/","page":"Numerics","title":"Numerics","text":"Some computations require the numerical approximation of derivatives, for example the evaluation of the electron velocity from the equation for electron current using the generalized Ohm's law, see Physics model. The derivatives are evaluated to second order using forward difference, central difference or backward difference depending on the location in the domain.","category":"page"},{"location":"tutorials/simulation/#Running-a-simulation","page":"Run a simulation","title":"Running a simulation","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"CurrentModule = HallThruster","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"In this tutorial, we will take you through running a simulation of an SPT-100 Hall thruster in HallThruster. Along the way, you will learn how to","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"install the HallThruster package\nconfigure simulation options \nrun a simulation\nexamine the results","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"We assume that you have a basic familiarity with the Julia programming language, and have installed Julia following the instructions on the Julia website. If this does not apply to you, you will want to familiarize yourself with Julia using the Getting started section of the Julia manual. We also assume you know what a Hall thruster is and have some understanding of their operation.","category":"page"},{"location":"tutorials/simulation/#Install","page":"Run a simulation","title":"Install","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"First, open Julia and type ']' to enter the Package REPL (Read-Evaluate-Print Loop) You should see the following prompt (the version may differ depending on your default Julia version).","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"(@v1.10) pkg>","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"To install HallThruster io your global environment, simply type ","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"(@v1.10) pkg> add HallThruster","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"This will download and precompile HallThruster and all of its dependencies. This works, but it is not always desirable to install packages to your global environment. Instead, it is common to have different packages loaded depending on your specific project. To do this, first create a new folder, which we'll call hallthruster_tutorial. Change directories into this folder, open Julia, and enter the package REPL. Type ","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"(@v1.10) pkg> activate .","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"to activate hallthruster_tutorial as its own environment. You should see v1.10 (or whatever version) be replaced with the name of your current folder. From there, you can install packages as normal, i.e.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"(hallthruster_tutorial) pkg> add HallThruster","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"This will create a file called Project.toml, which tracks the dependencies of the current environment. Environments are great for ensuring reproducability and portability of your Julia code. For example, if you want to send a script to a friend, sending the Project.toml file of your environment means they will be able to automatically download all of the packages you used in your script. Using one environment per project instead of the global environemnt means that your friend doesn't also have to download every single other package you happened to have installed, or manually install all of the packages you use in your script.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Once HallThruster has been installed, we're ready to begin writing and running our simulation code. Create a new file, perhaps called hallthruster_tutorial.jl and open it in your favorite text editor.","category":"page"},{"location":"tutorials/simulation/#Configure","page":"Run a simulation","title":"Configure","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"The first thing we need to do is tell your script that we want to use HallThruster. To do this, add the following to the beginning of your script.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"using HallThruster: HallThruster as het","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"This tells Julia that you want access to the HallThruster module. Since we will be accessing a lot of code in HallThruster, we also tell Julia that we want to refer to HallThruster as a shorter name, in this case het for Hall-effect thruster. You can leave this out, or change het to whatever you want.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"We need to tell HallThruster about what kind of simulation we want to run. This is the job of a Config. A Config struct contains most of the geometric, physical, and numerical information that HallThruster.jl needs in order to simulate a Hall thruster. There are a lot of options in a Config, but we will only use a few of them in this tutorial. You can read a full listing of these parameters, their effects, and their defaults on the Configuration page.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Only four parameters are absolutely required in a Config. These are","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"the thruster we want to simulate,\nthe discharge voltage,\nthe neutral mass flow rate at the anode,\nthe size of the simulation domain.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"We'll begin by constructing a Thruster A Thruster has four components – a name, a geometry, a magnetic field, and an optional flag that says whether the thruster is magnetically-shielded. The geometry is defined using a Geometry1D struct, which requires to specify the length of the discharge channel in combination with the inner and outer channel radii. For the SPT-100, a Geometry1D can be constructed like so:","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"using HallThruster: HallThruster as het\n\n# All units are SI unless explicitly specified\ngeom = het.Geometry1D(\n    channel_length = 0.025,\n    inner_radius = 0.0345,\n    outer_radius = 0.05,\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Note that all units are SI unless a unit is explicitly listed in the parameter name. As a result, Geometry1D expects dimensions in meters. If you would like to use explicit units, you can install and load either Unitful or DynamicQuantities, and specify dimensions as follows","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"DocTestSetup = quote\n    using HallThruster: HallThruster as het\n    using Unitful\n\n    geom = het.Geometry1D(\n        channel_length = 2.5u\"cm\",\n        inner_radius = 34.5u\"mm\",\n        outer_radius = 0.05u\"m\",\n    )\n\n    include_dirs = [\n        joinpath(het.PACKAGE_ROOT, \"test\", \"json\")\n    ]\n\n    bfield = het.load_magnetic_field(\"bfield_spt100.csv\"; include_dirs)\n\n    thruster = het.Thruster(\n        name = \"SPT-100\",\n        geometry = geom,\n        magnetic_field = bfield\n    )\n\n    config = het.Config(\n        thruster = thruster,\n        domain = (0.0, 0.08),\n        discharge_voltage = 300.0,\n        anode_mass_flow_rate = 5e-6,\n        propellant = het.Xenon,\n    )\n\n    simparams = het.SimParams(\n        grid = het.EvenGrid(100),   # an evenly-spaced grid with 100 cells\n        dt = 5u\"ns\",                  # a base timestep of 5 nanoseconds\n        duration = 1u\"ms\",            # run the simulation for one millisecond of simulated time\n        num_save = 1000,            # save 1000 frames of output\n    )\nend","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"using HallThruster: HallThruster as het\nusing Unitful # or `using DynamicQuantities`, if desired\n\ngeom = het.Geometry1D(\n    channel_length = 2.5u\"cm\",\n    inner_radius = 34.5u\"mm\",\n    outer_radius = 0.05u\"m\",\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"With the Geometry1D object constructed, we can turn to specifying the radial magnetic field. Unsurprisingly, we use a MagneticField struct for this. MagneticField has three fields — a filename and two arrays. The first array (z) specifies the axial coordinates (in meters) at which the magnetic field is known. The second (B) provides the magnetic field (in Tesla) at those points. While we can definitely manually pass these to MagneticField, in most cases you will want to pass a file instead. You can download a sample magnetic field file here.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Once you have downloaded the magnetic field file and placed it in your current working directory, you can load it using the load_magnetic_field function.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"bfield = het.load_magnetic_field(\"bfield_spt100.csv\")","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"If the magnetic field is in some other directory, you can tell load_magnetic_field to look for it using the include_dirs argument.  HallThruster will check the provided directories before looking in the present working directory.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"bfield = het.load_magnetic_field(\n    \"bfield_spt100.csv\"; \n    include_dirs = [\"/some/directory\", \"/another/directory\"]\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"With our geometry and magnetic field specified, we can finally create a Thruster.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"thruster = het.Thruster(\n    name = \"SPT-100\",\n    geometry = geom,\n    magnetic_field = bfield\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Now, we can set the rest of the options in Config. We'll use a discharge voltage of 300 V, a mass flow rate of 5 milligrams per second, and a domain length of 8 cm. We will also explicitly specify that the propellant is xenon.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"config = het.Config(\n    thruster = thruster,\n    domain = (0.0, 0.08),\n    discharge_voltage = 300.0,\n    anode_mass_flow_rate = 5e-6,\n    propellant = het.Xenon,\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"As with Geometry1D, units may be provided here using Unitful or DynamicQuantities, e.g","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"using Unitful\n\nconfig = het.Config(\n    thruster = thruster,\n    domain = (0.0u\"cm\", 8.0u\"cm\"),\n    discharge_voltage = 300.0u\"V\",\n    anode_mass_flow_rate = 5.0u\"mg/s\",\n    propellant = het.Xenon,\n)","category":"page"},{"location":"tutorials/simulation/#Run","page":"Run a simulation","title":"Run","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Now that we have created a Config struct, we can run our simulation. You might notice that we did not specify a timestep or a grid at any point. To do this, we make use of the SimParams struct.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"simparams = het.SimParams(\n    grid = het.EvenGrid(100),   # an evenly-spaced grid with 100 cells\n    dt = 5e-9,                  # a base timestep of 5 nanoseconds\n    duration = 1e-3,            # run the simulation for one millisecond of simulated time\n    num_save = 1000,            # save 1000 frames of output\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Here, we specified only four parameters, but SimParams has many more options that can be configured. See the page on Simulations for more details. These four are:","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"The grid, which we have set to an EvenGrid with 100 cells. We can alternatively use an UnevenGrid, which provides more resolution near the discharge channel and less in the plume. More information about these grids can be found on the Grid generation page.\nThe base timestep dt, in seconds. HallThruster uses adaptive timestepping by default, so typical timesteps will differ from the value provided here, but the base timestep is used in certain cases when the adaptive timestepping scheme gets stuck, or when uniform timestepping is explicitly requested (by passing adaptive=false to the SimParams struct). We give more detailed explanation of HallThruster's timestepping strategy on the Timestepping page.\nThe simulation duration, in seconds.\nThe number of frames we wish to save over the simulation runtime. Each frame captures the state of the simulation at a specific time. These are evenly spaced across duration.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"As always, units may be specified.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"simparams = het.SimParams(\n    grid = het.EvenGrid(100),   # an evenly-spaced grid with 100 cells\n    dt = 5u\"ns\",                # a base timestep of 5 nanoseconds\n    duration = 1u\"ms\",          # run the simulation for one millisecond of simulated time\n    num_save = 1000,            # save 1000 frames of output\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Finally, we can pass these to the run_simulation function, which runs the simulation and returns a Solution object.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"solution = het.run_simulation(config, simparams)\n\n# output\n\n[ Info: Simulation exited at t = 0.001 with retcode :success in 1.025520708 seconds.\nHall thruster solution with 1000 saved frames (retcode: success, end time: 0.001 seconds)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"The first line is printed when a simulation is completed (unless simparams.verbose = false) and tells us the run-time of our simulation. The second line provides a summary of the Hall thruster solution in question, telling us that the simulation has 1000 saved frames, that its end time is 1 ms (0.001 seconds), and, most importantly, that it succeeded (the return code or retcode is :success). If something goes wrong, the simulation will terminate early and the return code will be either failure or error. A return code of :failure means the simulation became unstable and blew up and a NaN or Inf was detected, while a return code of :error means some other error occurred.","category":"page"},{"location":"tutorials/simulation/#Analyze","page":"Run a simulation","title":"Analyze","text":"","category":"section"},{"location":"tutorials/simulation/#The-Solution-object","page":"Run a simulation","title":"The Solution object","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"The Solution object is made up of a few fields. These are ","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"retcode: The return code, described above.\nt: A Vector of times at which the simulation state is saved. The length of the vector is SimParams.num_save\nframes: A Vector of NamedTuples containing plasma properties at each of the times in t. The length of the vector is SimParams.num_save\nparams: A NamedTuple containing simulation parameters, the computational grid, and more.\nconfig: the Config we ran the simulation with\nerror: A string containing any errors that occurred, along with traceback information. This is empty if retcode is not :error","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"We can extract some useful global metrics from a solution, like thrust, dischargecurrent, and anodeefficiency.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"thrust = het.thruster(solution)\ndischarge_current = het.discharge_current(solution)\nanode_eff = het.anode_efficiency(solution)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"These functions return a vector of thrusts or discharge currents at each of the times in solution.t. There are serveral other functions that act analogously, computing efficiencies or other global metrics. A full listing of these can be found on the Postprocessing page.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Below, we use Makie to plot the discharge current over time for this specific simulation. We can see that the simulation begins with strong transient oscillations before settling down to a relatively stable steady state.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"using CairoMakie: Makie as mk\n\ncurrent = het.discharge_current(solution)\nf, ax, _ = mk.lines(\n    solution.t .* 1e6, current, \n    figure = (;\n        size = (800, 300)\n    ),\n    axis = (\n        xlabel = \"Time [microseconds]\",\n        ylabel = \"Discharge current [A]\",\n    )\n)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"(Image: )","category":"page"},{"location":"tutorials/simulation/#Average","page":"Run a simulation","title":"Average","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"If you want a time-averaged global metric, you could average one of these vectors yourself, or you could let HallThruster do it for you. For this purpose, HallThruster provides the time_average function, which averages an entire Solution object.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"avg = het.time_average(solution)\n\n# output\n\nHall thruster solution with 1 saved frame (retcode: success, end time: 0.001 seconds)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"The result of the time-averaging operation is a new Solution object containing a single frame. All of the normal functions that operate on Solution objects, like discharge_current, still work on a time-averaged Solution. This averaging can be partial—you can specify a frame index or time from which the averaging begins","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"avg = het.time_average(solution, 300)       # average starting at frame 300\navg = het.time_average(solution, 5e-4)      # average starting at 5e-4 seconds\navg = het.time_average(solution, 0.5u\"ms\")  # units are supported too, if Unitful or DynamicQuantities loaded","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"You can also index a Solution with an integer or range to extract a specific frame or range of frames, e.g.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"tenth_frame = solution[10]      # extract frame number 10 as a new Solution object\nmiddle_800 = solution[101:900]  # extract frames 101:900\navg_middle = het.time_average(solution[350:750])    # average frames 350 to 750","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Postprocessing functions like discharge_current and thrust work normally on the results of these operations as well.","category":"page"},{"location":"tutorials/simulation/#Extract-plasma-properties","page":"Run a simulation","title":"Extract plasma properties","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Lastly, we can obtain plasma properties by indexing a Solution object with a Symbol. For instance, if we want to extract the time-averaged ion velocity of singly-charged ions, we could do","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"avg = het.time_average(solution, 0.5u\"ms\")\n\nui_1 = avg[:ui, 1][]","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Here, :ui is a symbol telling HallThruster what field quantitity we want and 1 indicates that we want singly-charged ions.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"We can plot the extracted velocity using a plotting package like Makie.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"using CairoMakie: Makie as mk\n\navg = het.time_average(solution, 0.5u\"ms\")\n\n# extract the cell centers in meters, and multiply to convert to cm\nz_cm = avg[:z] .* 100\n\n# extract the ion velocity and convert to km/s\nui_km_s = avg[:ui, 1][] ./ 1000\n\nf, ax, ln = mk.lines(\n    z_cm, ui_km_s,\n    axis = (\n        xlabel = \"Axial coordinate [cm]\",\n        ylabel = \"Ion velocity [km]\")\n)\n\ndisplay(f)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"(Image: )","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"In the above, you can see that we used the same syntax to extract the cell centers of the grid using avg[:z].","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Many other parameters can be extracted this way, including","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"the magnetic field (:B)\nthe electron temperature (:Tev)\nthe plasma density (:ne)\nthe anomalous collision frequency (:nu_anom)","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"...and more! See Solutions for a full list.","category":"page"},{"location":"tutorials/simulation/#Conclusion","page":"Run a simulation","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Now you known how to run a basic simulation in HallThruster. You can specify a thruster and geometry, input operating conditions, select numerical properties, run the simulation, and extract useful data. In this tutorial, we left many of the options at their defaults, but HallThruster is highly configurable. You can change anomalous transport models, propellants, wall loss models, and more. If none of the built-ins are sufficient, you can even write your own models and create your own propellants. You can also run the code from python, or directly from a JSON input file. The rest of the documentation contains details about all of this and more.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"If you encounter an issue running the code, please file a GitHub issue. HallThruster is an evolving code, and new features are implemented on a regular basis. Requests for features and documentation improvement are also welcome, though we cannot guarantee that any specific features will be implemented.","category":"page"},{"location":"tutorials/simulation/","page":"Run a simulation","title":"Run a simulation","text":"Happy simulating!","category":"page"},{"location":"explanation/physics/#Physics-model","page":"Physics model","title":"Physics model","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"HallThruster.jl solves the 1-D quasineutral plasma equations of motion for a Hall thruster in the axial (z) direction, averaged across the thruster's discharge channel. We solve seperate models for neutral particles, ions, and electrons. Neutrals are assumed to have constant velocity and temperature and are tracked by a single continuity equation. Ions are assumed isothermal and unmagnetized. Multiple ion species with different charge states are supported, and each is tracked by a continuity equation and a momentum equation. We employ the drift-diffusion approximation for electrons, which reduces the electron momentum equation to a generalized Ohm's law. This, in combination with charge conservation, allows us to solve for the electrostatic potential and discharge current. Finally, we determine the electron temperature solving an equation for the conservation of electron internal energy.","category":"page"},{"location":"explanation/physics/#Neutrals","page":"Physics model","title":"Neutrals","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"For neutrals, the continuity equation is solved:","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    fracpartial n_npartial t + fracpartialpartial z (n_n u_n) = dotn_n","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Here, n_n is the neutral number density in m^-3, mathbfu_n is the neutral velocity vector in m/s, and dotn_n is the rate of neutral depletion due to ionization in  m^-3s^-1, which is given by","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    dotn_n = -sum_j = 1^3 n_e n_n k_nj(T_e)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"where n_e is the electron number density j represents the ion charge state (i.e. j = 1 represents singly-charged ions, and so on), T_e is the electron temperature, and k_nj is the rate coefficient of the ionization reaction","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"A + e^- rightarrow A^j+ + (j + 1) e^-","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"where A represents the gas species being simulated. Currently, the code is compatible with Xenon and Krypton. The reaction rate coefficients are generated as a function of electron temperature using the BOLSIG+ code. We read in a table of these rate coefficients with electron temperature and use the Interpolations.jl to generate transform this data into a continuous function. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The neutrals are assumed to have a constant velocity in the axial direction and a constant temperature, and are thus approximated monoenergetic and not Maxwellian. The neutral momentum and energy equations are not solved for. ","category":"page"},{"location":"explanation/physics/#Ions","page":"Physics model","title":"Ions","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"We solve continuity and momentum for each ion species. We may have the option for an ion energy equation, but for now they are treated as isothermal. The ion continuity equation for ions with charge j is","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    fracpartial n_ijpartial t + fracpartialpartial z (n_ij u_ij) = dotn_ij","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Here n_ij, u_ij, and dotn_ij are the number density, velocity, and net rate of production of ions with charge state j. The production rate dotn_ij is given by:","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    dotn_ij = n_e n_n k_nj(Te) - sum_ell = j + 1^3 n_e n_ij k_jell(T_e)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The first term here represents the rate of production of ions with charge state j and the second term represents the rate at which these ions are further ionized to become ions of charge state ell. In all, the following six reactions are modelled:","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"beginaligned\n    A + e^- rightarrow A^+ + 2 e^-\n    A + e^- rightarrow A^2+ + 3 e^-\n    A + e^- rightarrow A^3+ + 4 e^-\n    A+ + e^- rightarrow A^2+ + 2 e^-\n    A+ + e^- rightarrow A^3+ + 3 e^-\n    A^2+ + e^- rightarrow A^3+ + 2 e^-\nendaligned","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The currently-specified model does not include ion losses to the radial walls, but this could be included at a later date. Likewise, we could also include momentum-transfer collisions between ions and neutrals and between ions of different charge states at a future date, but neglect these for now. Future updates may also add the ability to model molecular propellants, not just monatomic ones, in which case we would need to add significantly more reaction equations, species, and model rotational and vibrational modes.","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The one-dimensional momentum equation for ions of charge state j is obtained by assuming the ions are unmagentized and that the momentum transfer due to collisions is negligible. The momentum equation in conservative form is","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    fracpartialpartial t (n_ij u_ij) + fracpartialpartial z (n_ij u_ij^2 + fracp_ijm_i) = fracj em_i n_ij E_z","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In this equation, p_ij = n_ij k_B T_i is the partial pressure of ions with charge j, T_i is the ion temperature, e is the fundamental charge, m_i is the ion mass, and E_z is the axial electric field. ","category":"page"},{"location":"explanation/physics/#Electrons","page":"Physics model","title":"Electrons","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"We assume that the plasma is quasineutral, which means that the local charge density is zero everywhere. This means that","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    n_e = sum_j=1^3 jn_ij","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In addition, the electrons are assumed to be massless. This yields a generalized Ohm's law, also known as the Quasineutral Drift Diffusion (QDD) model. The electron momentum equation becomes:","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    nu_e fracm_eemathbfj_e = e n_e mathbfE +nabla p_e - mathbfj_e times mathbfB","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Here, nu_e is the total electron momentum transfer collision frequency, mathbfj_e = -e n_e mathbfu_e is the electron current vector, p_e = n_e k_B T_e is the electron pressure, and B is the magnetic field. We want to model the electron velocity in both the axial (hatz) and azimuthal (theta) directions. Making the assumption that B is purely radial and that the plasma is axisymmetric, we arrive at the following two equations after some algebraic manipulations.","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    j_ez = frace^2 n_em_e nu_efrac11 + Omega_e^2left(E_z + frac1e n_efracpartial p_epartial zright)\n    j_etheta = Omega_e j_ez","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In this expression, Omega_e = omega_cenu_e = e B  m_e nu_e is the Hall parameter, or the ratio of the electron cyclotron frequency to the total electron momentum transfer collision frequency, and measures how well-magnetized the electrons are. Finally, we introduce the anomalous collision frequency (nu_AN):","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    nu_e = nu_c + nu_AN","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In Hall thrusters, the observed axial/cross-field electron current is significantly higher than that which would result from classical collisions alone (here, nu_c represents the classical electron momentum transfer collision frequency, see Collisions and Reactions). We model this enhanced transport in a fluid framework as an additional anomalous collision frequency, see Anomalous transport. The purpose of this code is to facilitate the development and testing of models for this important parameter.","category":"page"},{"location":"explanation/physics/#Discharge-current-and-electric-field","page":"Physics model","title":"Discharge current and electric field","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"To determine the electric field and discharge current we generally follow the method from V. Giannetti, et. al Numerical and experimental investigation of longitudinal oscillations in Hall thrusters, Aerospace 8, 148, 2021.  By writing the discharge current as fracI_dA_ch = j_e + j_i where A_ch is the channel area, plugging in Ohm's law for the electron current density, and integrating over the domain, we can write the discharge current as","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    I_d = fracDelta V + int_z_c^z_a frac1en_efracpartial p_epartial z + fracj_izen_emu_perp dzint_z_c^z_a en_e mu_perp A dz","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Where A is the cross section area of either the channel or plume, z_c and z_a are the cathode and anode positions, and Delta V j_iz and mu_perp are given by ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Delta V = V_d + V_s \nj_iz = Sigma_j=1^3 jn_ij u_ij \nmu_perp = fracem_e nu_e frac11+Omega_e^2","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"With the discharge current known, the axial electric field is computed locally as","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"E_z = fracI_den_emu_perpA_ch - frac1en_e fracpartial p_epartial z - fracj_izen_emu_perp ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"As the electric field is the negative gradient of the electrostatic potential, the potential is finally calculted by integrating the negative electric field using the trapezoid rule.","category":"page"},{"location":"explanation/physics/#Electron-energy-equation","page":"Physics model","title":"Electron energy equation","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The electron internal energy equation in one dimension is","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    fracpartialpartial tleft(frac32 n_e k_B T_eright) + fracpartialpartial zleft(frac52 n_e k_B T_e u_ez + q_ezright) = \n    n_e u_ez fracpartialphipartial z - W_loss - S_coll","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Here, q_ez is the electron heat conduction in one dimension and S_wall, see Wall Loss Models,  represents the loss of electron energy to the thruster walls and S_coll, see Collisions and Reactions captures the loss of energy due to inelastic collisions. The heat conduction is defined by Fourier's Law:","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"beginaligned\n    q_ez = -kappa_eperp nabla_perp T_e \nendaligned","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In this expression, kappa_eperp is the cross-field (axial) electron thermal conductivity, for which various forms exist. More details can be found on the Electron Thermal Conductivity page. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The heat transfer terms slightly change when considering the Landmark case study, while the different wall and inelastic collision loss models are described in Wall Loss Models and Collisions and Reactions. ","category":"page"},{"location":"explanation/physics/#Sheath-considerations","page":"Physics model","title":"Sheath considerations","text":"","category":"section"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"HallThruster.jl, being a fluid globally quasineutral model, is not designed to resolve plasma sheaths. However, the sheath and presheath are important to model Hall Thruster discharges accurately. As this is a 1D axial solver, we do not have any direct fluxes towards the walls, the energy losses can however be taken into account by a source term in the energy equation. This term and the boundary conditions implemented at the anode employ the following presheath approximations and assumptions. They are absolutely critical to replicate experimental Hall Thruster behaviour. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In the following, potential differences ephi are assumed to be on the order of the electron temperature k T_e. Furthermore, assume that cold ions fall through an arbitrary potential of phi_0 while they move towards the wall. Through conservation of energy, their arrival velocity at the sheath edge can be related to the potential difference. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    frac12 m_i v_0^2 = e phi_0","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Additionally, the ion flux during acceleration toward the wall is conserved. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    n_i v = n_0 v_0","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"The relation for ion velocity as a function of position in the sheath can be written as ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    frac12 m_i v^2 = frac12 m_i v_0^2 - ephi (x)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Rewriting both energy conservation and above expression for v_0 and v, and dividing gives","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    fracv_0v = sqrtfracphi_0phi_0 - phi","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"which by applying flux conservation results in ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    n_i = n_0 sqrtfracphi_0phi_0 - phi","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Close to the sheath edge the density equation can be expanded as a Taylor series, as phi is small compared to phi_0.","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    n_i = n_0 left(1 - frac12fracphiphi_0 + right)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In one dimension, neglecting collisions with other species and assuming isentropic temperature and pressure terms, no convection and no electron inertia, the electrons can be described by the Boltzmann relation.","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    n_e = n_0 expleft(frace phik T_eright)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"In this regime, the electron density is diffusion dominated and dictated by the electrostatic field. This assumption is generally valid along magnetic field lines and across weak magnetic fields with sufficient electron electron collisions. The Boltzmann relation can be expanded by assuming that the change in potential at the sheath edge is small compared to the electron temperature. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    n_e = n_0 left(1 - fracephik T_e +  right)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"Taking Poisson's equation of the form ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    nabla^2 phi = - fracek Te_0(n_i - n_e)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"and substituting expanded Boltzmann relation and expanded ion density leads after rearranging to ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    nabla^2 phi = frace n_0 phiepsilon_0left(frac12phi_0 - fracekT_eright)","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"As the sheath is assumed to be ion attracting, it can by definition not slow or repell ions. As a result, the right hand side of \\autoref{eq:poissonsubexpanded} has to always be positive, which leads to the following requirement. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    phi_0  frackT_e2e","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"By substituting energy conservation equation, the ion Bohm speed can be recovered. This condition is applied to the anode boundary and will be discussed in the boundary conditions. ","category":"page"},{"location":"explanation/physics/","page":"Physics model","title":"Physics model","text":"    v_0  sqrtfrackT_em_i","category":"page"},{"location":"reference/postprocessing/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"reference/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/postprocessing/#Types","page":"Postprocessing","title":"Types","text":"","category":"section"},{"location":"reference/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Postprocess","category":"page"},{"location":"reference/postprocessing/#HallThruster.Postprocess","page":"Postprocessing","title":"HallThruster.Postprocess","text":"struct Postprocess\n\nContains postprocessing options for a given simulation. When run_simulation(config, sim_params; postprocess = Postprocess(...)) is called with a non-empty output_file, HallThruster will write the simulation results to a JSON file. The results in the file will be transformed according to the fields.\n\nFields\n\noutput_file::String: The file to which the output will be written. If empty, no output will be written.\n\naverage_start_time::Float64: The time to begin averaging at. If less than zero, no averaged output will be written.\n\nsave_time_resolved::Bool: Whether time-resolved output will be saved. If true, each frame of the simulation will be written to the output file.\n\n\n\n\n\n","category":"type"},{"location":"reference/postprocessing/#Functions","page":"Postprocessing","title":"Functions","text":"","category":"section"},{"location":"reference/postprocessing/#Time-averaging","page":"Postprocessing","title":"Time-averaging","text":"","category":"section"},{"location":"reference/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"Time-averaging can be accomplished by providing a start time, or a starting frame.","category":"page"},{"location":"reference/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"time_average(sol::Solution, start_time)\ntime_average(sol::Solution, start_frame::Integer = 1)","category":"page"},{"location":"reference/postprocessing/#HallThruster.time_average-Tuple{HallThruster.Solution, Any}","page":"Postprocessing","title":"HallThruster.time_average","text":"time_average(\n    sol::HallThruster.Solution,\n    start_time\n) -> HallThruster.Solution{_A, _B, _C, S} where {_A, _B, _C, S<:(Vector)}\n\n\nAverage a Solution over time, starting at time start_time. Return a Solution object with a single frame containing the averaged simulation properties\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.time_average","page":"Postprocessing","title":"HallThruster.time_average","text":"time_average(\n    sol::HallThruster.Solution\n) -> HallThruster.Solution{_A, _B, _C, S} where {_A, _B, _C, S<:(Vector)}\ntime_average(\n    sol::HallThruster.Solution,\n    start_frame::Integer\n) -> HallThruster.Solution{_A, _B, _C, S} where {_A, _B, _C, S<:(Vector)}\n\n\nAverage a Solution over time, starting at frame start_frame. Return a Solution object with a single frame containing the averaged simulation properties\n\n\n\n\n\n","category":"function"},{"location":"reference/postprocessing/#Global-metrics","page":"Postprocessing","title":"Global metrics","text":"","category":"section"},{"location":"reference/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"These functions compute global metrics, i.e. thrust, currents, and efficiencies. Each has a version that computes the metric for the entire solution, and a version that acts on a specific frame.","category":"page"},{"location":"reference/postprocessing/","page":"Postprocessing","title":"Postprocessing","text":"thrust(sol::Solution, frame::Integer)\nthrust(sol::Solution)\ndischarge_current(sol::Solution, frame::Integer)\ndischarge_current(sol::Solution)\nanode_eff(sol::Solution, frame::Integer)\nanode_eff(sol::Solution)\ndivergence_eff(sol::Solution, frame::Integer)\ndivergence_eff(sol::Solution)\nion_current(sol::Solution, frame)\nion_current(sol::Solution)\nelectron_current(sol::Solution, frame)\nelectron_current(sol::Solution)\ncurrent_eff(sol::Solution, frame)\ncurrent_eff(sol::Solution)\nmass_eff(sol::Solution, frame)\nmass_eff(sol::Solution)\nvoltage_eff(sol::Solution, frame::Integer)\nvoltage_eff(sol::Solution) ","category":"page"},{"location":"reference/postprocessing/#HallThruster.thrust-Tuple{HallThruster.Solution, Integer}","page":"Postprocessing","title":"HallThruster.thrust","text":"thrust(sol::HallThruster.Solution, frame::Integer) -> Any\n\n\nCompute the thrust at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.thrust-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.thrust","text":"thrust(sol::HallThruster.Solution) -> Any\n\n\nCompute the thrust at a each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.discharge_current-Tuple{HallThruster.Solution, Integer}","page":"Postprocessing","title":"HallThruster.discharge_current","text":"discharge_current(\n    sol::HallThruster.Solution,\n    frame::Integer\n) -> Any\n\n\nCompute the discharge current at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.discharge_current-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.discharge_current","text":"discharge_current(sol::HallThruster.Solution) -> Any\n\n\nCompute the discharge current at a each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.anode_eff-Tuple{HallThruster.Solution, Integer}","page":"Postprocessing","title":"HallThruster.anode_eff","text":"anode_eff(sol::HallThruster.Solution, frame::Integer) -> Any\n\n\nCompute the anode efficiency at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.anode_eff-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.anode_eff","text":"anode_eff(sol::HallThruster.Solution) -> Any\n\n\nCompute the anode efficiency at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.divergence_eff-Tuple{HallThruster.Solution, Integer}","page":"Postprocessing","title":"HallThruster.divergence_eff","text":"divergence_eff(\n    sol::HallThruster.Solution,\n    frame::Integer\n) -> Any\n\n\nCompute the divergence efficiency at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.divergence_eff-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.divergence_eff","text":"divergence_eff(sol::HallThruster.Solution) -> Any\n\n\nCompute the divergence efficiency at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.ion_current-Tuple{HallThruster.Solution, Any}","page":"Postprocessing","title":"HallThruster.ion_current","text":"ion_current(sol::HallThruster.Solution, frame) -> Any\n\n\nCompute the ion current at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.ion_current-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.ion_current","text":"ion_current(sol::HallThruster.Solution) -> Any\n\n\nCompute the ion current at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.electron_current-Tuple{HallThruster.Solution, Any}","page":"Postprocessing","title":"HallThruster.electron_current","text":"electron_current(sol::HallThruster.Solution, frame) -> Any\n\n\nCompute the electron current at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.electron_current-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.electron_current","text":"electron_current(sol::HallThruster.Solution) -> Any\n\n\nCompute the electron current at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.current_eff-Tuple{HallThruster.Solution, Any}","page":"Postprocessing","title":"HallThruster.current_eff","text":"current_eff(sol::HallThruster.Solution, frame) -> Any\n\n\nCompute the current/beam utilization efficiency at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.current_eff-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.current_eff","text":"current_eff(sol::HallThruster.Solution) -> Any\n\n\nCompute the current/beam utilization efficiency at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.mass_eff-Tuple{HallThruster.Solution, Any}","page":"Postprocessing","title":"HallThruster.mass_eff","text":"mass_eff(sol::HallThruster.Solution, frame) -> Any\n\n\nCompute the mass utilization efficiency at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.mass_eff-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.mass_eff","text":"mass_eff(sol::HallThruster.Solution) -> Any\n\n\nCompute the mass utilization efficiency at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.voltage_eff-Tuple{HallThruster.Solution, Integer}","page":"Postprocessing","title":"HallThruster.voltage_eff","text":"voltage_eff(\n    sol::HallThruster.Solution,\n    frame::Integer\n) -> Any\n\n\nCompute the voltage/acceleration efficiency at a specific frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/postprocessing/#HallThruster.voltage_eff-Tuple{HallThruster.Solution}","page":"Postprocessing","title":"HallThruster.voltage_eff","text":"voltage_eff(sol::HallThruster.Solution) -> Any\n\n\nCompute the voltage/acceleration efficiency at each frame of a Solution.\n\n\n\n\n\n","category":"method"},{"location":"reference/config/#Configuration","page":"Configuration","title":"Configuration","text":"","category":"section"},{"location":"reference/config/","page":"Configuration","title":"Configuration","text":"The Config struct contains all of the options you need specify the physics, geometry, and numerics of a simulation. On this page, we will explain what options are available and what they do. As in all parts of the code, dimensional quantities are SI unless explicitly noted, but units may be provided using Unitful or DynamicQuantities","category":"page"},{"location":"reference/config/","page":"Configuration","title":"Configuration","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/config/","page":"Configuration","title":"Configuration","text":"Config{A <: AnomalousTransportModel, TC <: ThermalConductivityModel, W <: WallLossModel, HS <: HyperbolicScheme, IC <: InitialCondition, S_N, S_IC, S_IM, S_E,}","category":"page"},{"location":"reference/config/#HallThruster.Config","page":"Configuration","title":"HallThruster.Config","text":"struct Config{A<:HallThruster.AnomalousTransportModel, TC<:HallThruster.ThermalConductivityModel, W<:HallThruster.WallLossModel, HS<:HallThruster.HyperbolicScheme, IC<:HallThruster.InitialCondition, S_N, S_IC, S_IM, S_E}\n\nHall thruster configuration struct. Only four mandatory fields: discharge_voltage, thruster, anode_mass_flow_rate, and domain.\n\nMandatory Fields\n\nthruster::HallThruster.Thruster: The thruster to simulate. See Thrusters for more information\n\ndomain::Tuple{Float64, Float64}: The simulation domain, given as (left, right). Dimensions are in meters.\n\ndischarge_voltage::Float64: The potential difference between anode and cathode, in V. Used to set the left boundary condition for electrostatic potential.\n\nanode_mass_flow_rate::Float64: The mass flow rate of neutral atoms through the anode, in kg/s.\n\nOptional fields\n\n\nncharge::Int64: Maximum ion charge state. Default: 1.\n\npropellant::HallThruster.Gas: A Gas. See Propellants for more. Default: Xenon.\n\ncathode_coupling_voltage::Float64: The potential at the right boundary of the simulation. Default: 0\n\nanode_boundary_condition::Symbol: Can be either :sheath or :dirichlet. If :sheath, electron temperature has a Neumann boundary condition at the anode and a self-consistent anode sheath potential is computed. If :dirichlet, electron temperature at anode is set to anode_Tev and no sheath potential is modeled. Default: :sheath.\n\nanode_Tev::Float64: Electron temperature at left boundary (anode) if anode_boundary_condition == :sheath. Default: 2.0.\n\ncathode_Tev::Float64: Electron temperature at right boundary (cathode). Default: 2.0\n\nanom_model::HallThruster.AnomalousTransportModel: Model for computing the anomalous collision frequency. See Anomalous Transport for more info. Default: TwoZoneBohm(1/160, 1/16).\n\nwall_loss_model::HallThruster.WallLossModel: How radial losses due to sheaths are computed. Other wall models are described on the Wall Loss Models page. Default: WallSheath(BNSiO2, 1.0).\n\nconductivity_model::HallThruster.ThermalConductivityModel: Model for the cross-field electron thermal conductivity. See Electron Thermal Conductivity for more. Default: Mitchner()\n\nelectron_ion_collisions::Bool: Whether to include electron-ion collisions. See Collisions and Reactions for more. Default: true.\n\nneutral_velocity::Float64: Neutral velocity in m/s. Default: 300.0, or if neutral_temperature is set, that parameter is used to compute the velocity using a one-sided maxwellian flux approximation.\n\nneutral_temperature_K::Float64: Neutral temperature in Kelvins. Default: 500.0.\n\nion_temperature_K::Float64: Ion temperature in Kelvins. Default: 1000.0\n\nion_wall_losses::Bool: Whether we model ion losses to the walls. Default: false.\n\nbackground_pressure_Torr::Float64: The pressure of the background neutrals, in Pascals. These background neutrals are injected at the anode to simulate the ingestion of facility neutrals. Default: 0.0\n\nbackground_temperature_K::Float64: The temperature of the background neutrals, in K. Default: 150.0.\n\nneutral_ingestion_multiplier::Float64: The factor by which the ingested mass flow rate computed from the background pressure and temperature is multiplied. Default: 1.\n\nsolve_plume::Bool: Whether quasi-1D beam expansion should be modelled outside of the channel. See Quasi-1D plume model for more. Default: false\n\napply_thrust_divergence_correction::Bool: Whether the thrust output by HallThruster.jl should include a divergence correction factor of cos(divergence_angle). Default: false.\n\nelectron_plume_loss_scale::Float64: The degree to which radial electron losses are applied in the plume. See Wall Loss Models for more information. Default: 1.\n\nmagnetic_field_scale::Float64: Factor by which the magnetic field is increased or decreased compared to the one in the provided Thruster struct. Default: 1.0.\n\ntransition_length::Float64: Distance over which the transition between inside and outside the channel is smoothed. Affects wall losses as well as two-zone Bohm-like transport models. Default: 0.1 * thruster.geometry.channel_length\n\nscheme::HallThruster.HyperbolicScheme: Numerical scheme to employ for integrating the ion equations. This is a HyperbolicScheme struct with fields flux_function, limiter, and reconstruct. See Schemes for more info. Default: HyperbolicScheme(flux_function = rusanov, limiter = van_leer, reconstruct = true).\n\ninitial_condition::HallThruster.InitialCondition: An InitialCondition; see Initialization for more information. Default: DefaultInitialization().\n\nimplicit_energy::Float64: The degree to which the energy is solved implicitly. 0.0 is a fully-explicit forward Euler, 0.5 is Crank-Nicholson, and 1.0 is backward Euler. Default: 1.0.\n\nreaction_rate_directories::Vector{String}: Additional directories in which we should look for rate coefficients. These are searched before the default directory, so replacement rate coefficients for built-in propellants can be provided. Default: String[]\n\nanom_smoothing_iters::Int64:  How many times to smooth the anomalous transport profile. Only useful for transport models that depend on the plasma properties. Default: 0\n\nVerification and validation options\n\nThese options are used in code benchmarking and verification and are not usually needed by end-users. See Verification and validation for an explanation of how we use these to verify the accuracy of the code.\n\nLANDMARK::Bool: Whether we are using the physics model from the LANDMARK benchmark. This affects whether certain terms are included in the equations, such as electron and heavy species momentum transfer due to ionization and the form of the electron thermal conductivity. Default: false.\n\nionization_model::Symbol: Model for ionization reactions. Default: :Lookup.\n\nexcitation_model::Symbol: Model for excitation reactions. Default: :Lookup.\n\nelectron_neutral_model::Symbol: Model for elastic scattering collisions between electrons and neutral atoms. Default: :Lookup.\n\nsource_neutrals::Any: Extra user-provided neutral source term. Default: nothing\n\nsource_ion_continuity::Any: Vector of extra source terms for ion continuity, one for each charge state. Default: nothing.\n\nsource_ion_momentum::Any: Vector of extra source terms for ion momentum, one for each charge state. Default: nothing.\n\nsource_energy::Any: Extra source term for electron energy equation. Default: nothing.\n\n\n\n\n\n","category":"type"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"EditURL = \"NEWS.md\"","category":"page"},{"location":"NEWS/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"NEWS/#v0.18.3","page":"Release notes","title":"v0.18.3","text":"","category":"section"},{"location":"NEWS/#Bug-fixes","page":"Release notes","title":"Bug fixes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"Fix indexing error in rate coefficient calculation\nFix massive divergence angles when ion velocity is zero or negative","category":"page"},{"location":"NEWS/#v0.18.2","page":"Release notes","title":"v0.18.2","text":"","category":"section"},{"location":"NEWS/#New-features","page":"Release notes","title":"New features","text":"","category":"section"},{"location":"NEWS/#Anomalous-transport-models","page":"Release notes","title":"Anomalous transport models","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"A new SimpleLogisticShift pressure shift model has been added. This is a simplified version of the LogisticPressureShift with one fewer parameter. See Anomalous transport for more details.","category":"page"},{"location":"NEWS/#v0.18.1","page":"Release notes","title":"v0.18.1","text":"","category":"section"},{"location":"NEWS/#Minor-changes","page":"Release notes","title":"Minor changes","text":"","category":"section"},{"location":"NEWS/#Anomalous-transport-models-2","page":"Release notes","title":"Anomalous transport models","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"The pressure shift now only applies to the coefficients of the transport model as opposed to shifting the entire magnetic field. This was the pre-0.18.0 behavior.","category":"page"},{"location":"NEWS/#v0.18.0","page":"Release notes","title":"v0.18.0","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"warning: Breaking release\nv0.18.0 is a breaking release, made as part of our effort to move toward v1.0.0 in the next few months. Users may need to update their code to avoid errors.  Check out the list of changes and removals below to see how to migrate your code.","category":"page"},{"location":"NEWS/#Major-changes","page":"Release notes","title":"Major changes","text":"","category":"section"},{"location":"NEWS/#Precompilation-and-load-time","page":"Release notes","title":"Precompilation and load time","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"We have significantly reduced our load times by removing dependencies. We have also added a significant amount of additional precompilation work to reduce the time-to-first-simulation for most users.\nWith these improvements, HallThruster.jl may be suitable for use in a scripting workflow, depending on the expected run-time of your simulations.\nFor many users and workflows, the total time-to-first-simulation should be just a few seconds.","category":"page"},{"location":"NEWS/#Exports","page":"Release notes","title":"Exports","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"Xenon, Krypton, and time_average are no longer exported. Users will need to use the fully-qualified names, i.e. HallThruster.Xenon, HallThruster.Krypton, and HallThruster.time_average to access these variables. This can be made less verbose by bringing HallThruster into scope with a shorter name:","category":"page"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"using HallThurster: HallThruster as het\n\nhet.Xenon","category":"page"},{"location":"NEWS/#Postprocessing-changes","page":"Release notes","title":"Postprocessing changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"The run_simulation function now takes an optional postprocess keyword argument, which takes a Postprocess object.\nThe Postprocess struct allows the user to specify time-averaging, saving, and output info. Any requested postprocessing will be performed automatically after the simulation has finished and output the requested JSON file.\nSee Postprocessing for more information","category":"page"},{"location":"NEWS/#JSON-IO","page":"Release notes","title":"JSON IO","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"JSON input and output has been significantly reworded and enhanced.  See  Use JSON for input and output for more information. Users of the old JSON interface will need to update their input files to conform to the new format. Some of the changes include:","category":"page"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"JSON inputs now map directly onto the Config structs used by HallThruster.jl elsewhere. The key names are now identical between the JSON input and the Config struct.\nJSON outputs now contain all input used to run the simulation, including a Config (under key \"config\") and timestepping info (under key \"simulation\").\nJSON outputs can be used to restart simulations, replacing the restart capability previously provided by JLD2.\nUsers can provide postprocessing directives in the JSON input by providing a \"postprocessing\" key in their input, following the Postprocessing interface introduced in this update.","category":"page"},{"location":"NEWS/#Python-interface","page":"Release notes","title":"Python interface","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"We have a new python interface. See Run a simulation from python for more.","category":"page"},{"location":"NEWS/#Interface-changes","page":"Release notes","title":"Interface changes","text":"","category":"section"},{"location":"NEWS/#Configuration-changes","page":"Release notes","title":"Configuration changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"The following keys have been renamed to better express the expected units.\nanode_Te -> anode_Tev\ncathode_Te -> cathode_Tev\nion_temperature -> ion_temperature_K\nneutral_temperature -> neutral_temperature_K\nbackground_neutral_temperature -> background_temperature_K\nbackground_pressure -> background_pressure_Torr\ncathode_potential -> cathode_coupling_voltage\nThe following keys have been removed.\nmin_electron_temperature (now set to the min(anode_Tev, cathode_Tev))\nmin_number_density (now set to 1e6)\nThe following keys have had their options changed\nionization_model: Formerly took a value of type IonizationModel, now takes a Symbol (one of :Lookup or :Landmark)\nexcitation_model: Formerly took a value of type ExcitationModel, now takes a Symbol (one of :Lookup or :Landmark)\nelectron_neutral_model: Formerly took a value of ElectronNeutralModel, now takes a Symbol (one of None, :Lookup or :Landmark)\nSee Configuration for a full list of options and default values.","category":"page"},{"location":"NEWS/#Simulation-changes","page":"Release notes","title":"Simulation changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"A new struct SimParams has been created to hold timestepping and grid generation options\nrun_simulation can now be called as run_simulation(config::Config, simparams::SimParams).\nSee Simulations for more information.","category":"page"},{"location":"NEWS/#Solution-changes","page":"Release notes","title":"Solution changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"u has been removed from Solution\nSolution.savevals has been renamed to frames\nSolution.config contains the Config used to run the simulation\nSolution.error captures any errors that are produced during a run\nRetcode options have changed. The options are now :success, :failure, and :error. :success denotes a successful simulation, as before. :failure indicates a numerical instability, and :error captures any cases in which the simulation would have thrown an exception. The error text is captured in Solution.error.","category":"page"},{"location":"NEWS/#Wall-loss-model-changes","page":"Release notes","title":"Wall loss model changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"The parameter α of the WallSheath model has been renamed to loss_scale and has a default value of 1.0.\nSee Wall Loss Models for more information.","category":"page"},{"location":"NEWS/#Grid-generation-changes","page":"Release notes","title":"Grid generation changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"UnevenGrid no longer takes a custom density function as an input.\nSee Grid generation for more information.","category":"page"},{"location":"NEWS/#Anomalous-transport-model-changes","page":"Release notes","title":"Anomalous transport model changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"ShiftedTwoZoneBohm, ShiftedGaussianBohm, and ShiftedMultiBohm have been removed.\nThe model LogisticPressureShift has been added. This takes another anom model as a parameter and applies the same pressure-dependent shift as seen in these models.\nTo migrate to the new system, replace ShiftedGaussianBohm or similar with LogisticPressureShift(GaussianBohm(...), ...).\nThe dz and z0 parameters of LogisticPressureShift are now in terms of channel length rather than meters\nAdded the GaussianBohm model\nRenamed the parameters of the ShiftedGaussianBohm/GaussianBohm model. The new parameters are:\nhall_min: the minimum Hall parameter\nhall_max: the maximum Hall parameter\nwidth: the width of the Gaussian subtraction from the Bohm-like transport model.\ncenter: the center of the Gaussian subtraction\nSee Anomalous transport for a full listing of anomalous transport options.","category":"page"},{"location":"NEWS/#Thruster-changes","page":"Release notes","title":"Thruster changes","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"Thruster.magnetic_field now takes a MagneticField object, which contains a filename, z-coordinates, and magnetic field values. Arbitrary functions are no longer supported. If only a filename is provided, the constructor will load the magnetic field from the provided file.\nB_field_SPT_100 has been renamed to spt100_analytic_field\ngeometry_SPT_100 has been renamed to spt100_geometry\nSee Thrusters for more information.","category":"page"},{"location":"NEWS/#Removals","page":"Release notes","title":"Removals","text":"","category":"section"},{"location":"NEWS/","page":"Release notes","title":"Release notes","text":"The IonizationModel, ExcitationModel, and ElectronNeutralModel interfaces have been removed in favor of a simpler Symbol-based lookup system.\nThe GKElectronNeutral model has been removed entirely.\nSerialization using JLD2 has been removed in favor of the JSON-based system described above.\nPlotting capabilities are no longer provided by HallThruster.jl directly. ","category":"page"},{"location":"reference/solution/#Solutions","page":"Solution","title":"Solutions","text":"","category":"section"},{"location":"reference/solution/","page":"Solution","title":"Solution","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/solution/#Types","page":"Solution","title":"Types","text":"","category":"section"},{"location":"reference/solution/","page":"Solution","title":"Solution","text":"Solution","category":"page"},{"location":"reference/solution/#HallThruster.Solution","page":"Solution","title":"HallThruster.Solution","text":"struct Solution{T, P, C, S}\n\nThe solution of a simulation, returned by run_simulation. These can be passed to any of the postprocessing functions described in Postprocessing, or indexed to extract specific values.\n\nIndexing\n\nThere are a few ways to index a solution. First, you can extract a solution containing a single frame by indexing the Solution by an integer.\n\njulia> solution = het.run_simulation(config, simparams)\nHall thruster solution with 101 saved frames (retcode: success, end time: 0.001 seconds)\n\njulia> solution[51]\nHall thruster solution with 1 saved frame (retcode: success, end time: 0.0005 seconds)\n\nSecond, you can index a solution by a vector or vector-like object to extract a range of frames\n\njulia> solution[51:end] # get last 51 frames\nHall thruster solution with 51 saved frames (retcode: success, end time: 0.001 seconds)\n\njulia> solution[begin:2:end] # get every other frame\nHall thruster solution with 51 saved frames (retcode: success, end time: 0.001 seconds)\n\njulia> solution[[1, 51, 101]] # get only frames 1, 51, 101\nHall thruster solution with 3 saved frames (retcode: success, end time: 0.001 seconds)\n\nLastly, you can index by a symbol or [Symbol, Integer] to get plasma data for all frames in that solution\n\nsolution[:ni, 1] \t# get ion density of first charge state for all frames\nsolution[:ui] \t\t# get ion velocity for all charge states and frames\n\n# These return the same thing\nsolution[:∇pe]\nsolution[:grad_pe]\n\nFor a list of valid fields to index by, call HallThruster.valid_fields() For a list of alternate names for fields containing special characters, call HallThruster.alternate_field_names()\n\nSee the documentation for Base.getindex(sol::Solution, field::Symbol) and Base.getindex(sol::Solution, field::Symbol, charge::Integer) for more information.\n\nFields\n\nt::Any: A vector of times (in seconds) at which simulation output has been saved\n\nframes::Any: A vector of frames, or snapshots of the simulation state, at the times specified in t\n\nparams::Any: The solution parameters vector. Contains auxilliary information about the simulation.\n\nconfig::Any: The Config used to run the simulation\n\nretcode::Symbol: The solution return code. This can be one of three values:\n:success: the simulation completed successfully.\n:failure: the simulation failed due to a numerical issue or instability, resulting in a NaN or Inf being detected somewhere in the solution\n:error: another error occurred. Check the error string to see what kind of error.\n\nerror::String: Holds to error text and backtrace, if an error occurred. Empty if sol.retcode != :error.\n\n\n\n\n\n","category":"type"},{"location":"reference/solution/#Functions","page":"Solution","title":"Functions","text":"","category":"section"},{"location":"reference/solution/","page":"Solution","title":"Solution","text":"write_to_json\nvalid_fields\nalternate_field_names\nBase.getindex(sol::Solution, frame::Integer)\nBase.getindex(sol::Solution, frames::AbstractVector)\nBase.getindex(sol::Solution, field::Symbol)\nBase.getindex(sol::Solution, field::Symbol, charge::Integer)","category":"page"},{"location":"reference/solution/#HallThruster.write_to_json","page":"Solution","title":"HallThruster.write_to_json","text":"write_to_json(\n    file::String,\n    sol::HallThruster.Solution;\n    average_start_time,\n    save_time_resolved\n)\n\n\nWrite sol to file, if file is a JSON file.\n\nMandatory arguments\n\nfile: the file to which we write the solution\nsol: the Solution object to be written\n\nOptional keyword args\n\naverage_start_time = -1: the time at which averaging begins. If < 0, no averaged output is written.\nsave_time_resolved = true: Whether to save all frames of the simulation. If false, no time-resolved output is written.\n\n\n\n\n\n","category":"function"},{"location":"reference/solution/#HallThruster.valid_fields","page":"Solution","title":"HallThruster.valid_fields","text":"valid_fields()\n\n\nReturns a Tuple of symbols containing fields that can be obtained by indexing a Solution by a Symbol. This contains fields actually saved in a frame, in addition to special fields like :z and :B, as well as alternate field names for fields with special characters in their names (see HallThruster.alternate_field_names() for more)\n\njulia> HallThruster.valid_fields()\n(:z, :B, :E, :μ, :Tev, :ϕ, :∇ϕ, :ne, :pe, :ue, :∇pe, :νan, :νc, :νen, :νei, :radial_loss_frequency, :νew_momentum, :νiz, :νex, :νe, :Id, :ji, :nn, :anom_multiplier, :ohmic_heating, :wall_losses, :inelastic_losses, :Vs, :channel_area, :inner_radius, :outer_radius, :dA_dz, :tanδ, :anom_variables, :dt, :ni, :ui, :niui, :mobility, :potential, :thermal_conductivity, :grad_pe, :nu_anom, :nu_class, :nu_wall, :nu_ei, :nu_en, :nu_iz, :nu_ex, :tan_divergence_angle, :E, :ωce, :cyclotron_freq)\n\n\n\n\n\n","category":"function"},{"location":"reference/solution/#HallThruster.alternate_field_names","page":"Solution","title":"HallThruster.alternate_field_names","text":"alternate_field_names()\n\n\nReturns a NamedTuple of mappings between alternate ascii field names and field names with special characters. These can be used when indexing Solution objects instead of the short names.\n\nUsage\n\njulia> HallThruster.alternate_field_names()\n(mobility = :μ, potential = :ϕ, thermal_conductivity = :κ, grad_pe = :∇pe, nu_anom = :νan, nu_class = :νc, nu_wall = :νew_momentum, nu_ei = :νei, nu_en = :νen, nu_iz = :νiz, nu_ex = :νex, tan_divergence_angle = :tanδ)\n\n\n\n\n\n","category":"function"},{"location":"reference/solution/#Base.getindex-Tuple{HallThruster.Solution, Integer}","page":"Solution","title":"Base.getindex","text":"getindex(\n    sol::HallThruster.Solution,\n    frame::Integer\n) -> HallThruster.Solution{T, _A, _B, S} where {T<:(Vector), _A, _B, S<:(Vector)}\n\n\nReturn a solution where frames = [sol.frames[frame]] and [t = sol.t[frame]] All other fields remain unchanged.\n\n\n\n\n\n","category":"method"},{"location":"reference/solution/#Base.getindex-Tuple{HallThruster.Solution, AbstractVector}","page":"Solution","title":"Base.getindex","text":"getindex(\n    sol::HallThruster.Solution,\n    frames::AbstractVector\n) -> HallThruster.Solution\n\n\nReturn a solution where result.frames = sol.frames[frames] and result.t = sol.t[frames]. This can be used to extract a contiguous slice of frames (by passing in a range like 50:end) or a discrete sub-selection of frames (by passing in a vector like [1, 51, 100])\n\n\n\n\n\n","category":"method"},{"location":"reference/solution/#Base.getindex-Tuple{HallThruster.Solution, Symbol}","page":"Solution","title":"Base.getindex","text":"getindex(sol::HallThruster.Solution, field::Symbol) -> Any\n\n\nReturn plasma data indicated by the field for every frame in sol. Type of returned data depends on the specific field. A list of valid fiels can be found by calling HallThruster.valid_fields(). Most of these return a vector of vectors, i.e. [[field at time 0], [field at time 1], ...]\n\nFor ion quantities, this method does not select a specific charge state. Calling sol[:ni] returns a vector of ncharge x ncells matrices, each of which contains the density of ions on the grid for every charge state. To get a specific charge, call sol[:ni, Z] where 1 <= Z <= ncharge and ncharge is the maximum charge state of the simulation.\n\nThere are some special-cased convenience fields as well, which may return different values.\n\n:B: returns the magnetic field in each grid cell. Always returns a vector rather than vector of vectors, as the magnetic field is static.\n:cyclotron_freq or ωce: returns the electron cyclotron frequency (e * B / m_e)as a vector of vectors.\n:E: returns the electric field -∇ϕ as a vector of vectors.\n:z: returns the cell center locations for the grid as a vector.\n\nAdditionally, for values in saved_fields with non-ascii/special characters in their names, we provide alternate accessors, a list of which can be found by calling HallThruster.alternate_field_names()\n\n\n\n\n\n","category":"method"},{"location":"reference/solution/#Base.getindex-Tuple{HallThruster.Solution, Symbol, Integer}","page":"Solution","title":"Base.getindex","text":"getindex(\n    sol::HallThruster.Solution,\n    field::Symbol,\n    charge::Integer\n) -> Any\n\n\nFor ion quantities (:ni, :ui, and :niui), indexing as sol[field, charge] returns a vector of vectors with the field for charge-charged ions. As an example, sol[:ui, 1] returns the velocity of singly-charged ions for every frame in sol.frames. For non-ion quantities, passing an integer as a second index causes an error.\n\n\n\n\n\n","category":"method"},{"location":"reference/collisions/#Collisions-and-Reactions","page":"Collisions and reactions","title":"Collisions and Reactions","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"HallThruster.jl allows you to choose from a few different models for ionization, excitation and elastic scattering, or supply your own. This allows you to implement different propellants or more charge states for an existing propellant.","category":"page"},{"location":"reference/collisions/#Background","page":"Collisions and reactions","title":"Background","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Most collisions in HallThruster.jl are handled via the Reaction interface. This is an abstract type with three subtypes: IonizationReaction, ExcitationReaction, and ElasticScattering.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"The core of the ionization model in HallThruster.jl is the IonizationReaction struct. It has four fields: energy,  reactant, product, and rate_coeff. The first is of type Float64 and is the ionization energy of the given reaction in eV. The next two are Species objects, while the last is an arbitrary function. This rate_coeff computes the ionization reaction rate coefficient (in m^3/s) provided the electron energy (in eV).  It is used in heavy species source terms in order to compute the production or destruction of the reactant and product due to ionization, and in the electron energy equation in order to compute electron energy losses due to inelastic ionization collisions.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Excitation reactions are handled similarly. The ExcitationReaction struct has only three fields: energy, reactant and rate_coeff, with the same types as above. Since fluids of different excitation levels are not tracked explicitly, the choice of excitation model only affects the electron energy balance.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Elastic scattering (electron-neutral) collisions are implemented via the ElasticCollision struct, which has two fields: reactant and rate_coeff, as no energy is lost in such collisions. This affects the electron momentum balance and the cross-field transport.","category":"page"},{"location":"reference/collisions/#Ionization","page":"Collisions and reactions","title":"Ionization","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"HallThruster.jl provides two models out of the box. These are","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Model Supported species Maximum charge state Description\nIonizationLookup Xenon, Krypton (out of the box. With user-provided tables, can support any species) 3 Ionization look-up table for species provided with HallThruster.jl. By default, the tables are stored in the reactions subfolder of the HallThruster.jl directory, but the user may provide additional directories in which to look for tables.\nLandmarkIonizationLookup Xenon 1 Lookup table provided for the LANDMARK benchmark. Table is stored in the landmark subfolder of the HallThruster.jl directory.","category":"page"},{"location":"reference/collisions/#IonizationLookup","page":"Collisions and reactions","title":"IonizationLookup","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This is the default ionization model. To use the IonizationLookup model, initialize it as follows:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"ionization_model = IonizationLookup([directories::Vector{AbstractString = String[]}])","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"If the optional argument directories is left empty or unprovided, the HallThruster.jl will only look in the reactions subfolder of the HallThruster.jl main directory. Otherwise, HallThruster.jl will preferentially look in directories before before falling back to the included tables. If two files in user-provided directories have the same name, HallThruster.jl will pick the one in the directory which comes first in directories.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Inside of the folders listed in directories, HallThruster.jl will look for rate coefficient files matching the desired propellant gas and maximum charge state.  The rate coefficient files must be named as follows in order to be found.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"ionization_$(reactant.symbol)_$(product.symbol).dat","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"For example, for a reaction file containing rate coefficients for direct double ionization of Bismuth, you would name the file ionization_Bi_Bi2+.dat, or for Argon II being ionized to Argon III, it would be ionization_Ar2+_Ar3+.dat.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"The rate coefficient files must have the ionization energy in the first row, with a colon separating the descriptor and the number. It must next have a header row (which is skipped on load), followed by two tab-delimited columns. The first should have the electron energy (note: this is 3/2 Te) in eV, and the second should have the  rate coefficient in m^3/s. The first few rows of the ionization_Kr_Kr+.dat folder thus reads","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Ionization energy (eV): 13.9996055\nEnergy (eV) Rate coefficient (m3/s)\n1.0 1.812780887933804e-23\n2.0\t6.784605416289418e-19\n3.0\t2.86241339516785e-17\n4.0\t2.0154931458303006e-16\n5.0\t6.77202352079487e-16\n6.0\t1.5567995341077301e-15\n7.0\t2.8667673314913722e-15\n8.0\t4.5818881444694e-15\n9.0\t6.650747725094247e-15","category":"page"},{"location":"reference/collisions/#LandmarkIonizationLookup","page":"Collisions and reactions","title":"LandmarkIonizationLookup","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This accounts for single ionization of Xenon only using the lookup table provided by test case 3 of the LANDMARK benchmark. It reads from the file landmark/landmark_rates.csv.  Useful mostly for replicating the LANDMARK benchmark.","category":"page"},{"location":"reference/collisions/#Excitation","page":"Collisions and reactions","title":"Excitation","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"As with ionization, HallThruster.jl provides two models out of the box. These are","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Model Supported species Description\nExcitationLookup Xenon, Krypton (out of the box. With user-provided tables, can support any species) Excitation look-up table for species provided with HallThruster.jl. By default, the tables are stored in the reactions subfolder of the HallThruster.jl directory, but the user may provide additional directories in which to look for tables.\nLandmarkExcitationLookup Xenon Lookup table provided for the LANDMARK benchmark. Table is stored in the landmark subfolder of the HallThruster.jl directory.","category":"page"},{"location":"reference/collisions/#ExcitationLookup","page":"Collisions and reactions","title":"ExcitationLookup","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This is the default excitation model. To use the ExcitationLookup model, initialize it as follows:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"excitation_model = ExcitationLookup([directories::Vector{AbstractString = String[]}])","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This functions nearly identically to the IonizationLookup, with the exception that, since excitation reactions do not change the charge state, the product is the same Species as the reactant and thus is not included in the filename. The filename for excitation reactions is thus:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"excitation_$(reactant.symbol).dat","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"For example, for a reaction file containing excitation rate coefficients for neutral Argon would be called excitation_Ar.dat. Similarly, a file containing rates for excitation of triply-charged Xenon would be called excitation_Xe3+.dat.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"The rate coefficient files are formatted identically to the ionization rate files. Below are the first few lines of the included excitation_Xe.dat.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Excitation energy (eV): 8.32\nEnergy (eV)\tRate coefficient (m3/s)\n1.0\t2.909965013767145e-20\n2.0\t3.078734312855916e-17\n3.0\t4.1547515755380286e-16\n4.0\t1.6649256403317016e-15\n5.0\t3.9526948476759076e-15\n6.0\t7.124788357557455e-15\n7.0\t1.0908925177391674e-14\n8.0\t1.5042335588913955e-14\n9.0\t1.9316662863621785e-14","category":"page"},{"location":"reference/collisions/#LandmarkIonizationLookup-2","page":"Collisions and reactions","title":"LandmarkIonizationLookup","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This accounts for excitation of Xenon only using the lookup table provided by test case 3 of the LANDMARK benchmark. It reads from the file landmark/landmark_rates.csv.  Useful mostly for replicating the LANDMARK benchmark. LANDMARK does explicitly provide excitation rates, and instead gives an energy loss coefficient. However, using the provided ionization rate coefficients, we can back out the excitation rate coefficients. These are then used to construct an ExcitationReaction.","category":"page"},{"location":"reference/collisions/#Electron-neutral-elastic-scattering","page":"Collisions and reactions","title":"Electron-neutral elastic scattering","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"These are ReactionModels of type ElectronNeutralModel. HallThruster.jl provides three models out of the box. These are","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Model Supported species Description\nElectronNeutralLookup Xenon, Krypton (out of the box. With user-provided tables, can support any species) Electron-neutral elastic scattering look-up table for species provided with HallThruster.jl. By default, the tables are stored in the reactions subfolder of the HallThruster.jl directory, but the user may provide additional directories in which to look for tables.\nLandmarkElectronNeutral Xenon Constant rate coefficient of 2.5e-13\nGKElectronNeutral Xenon Uses Eq. 36.13 on pg. 58 from Goebel and Katz to fit Xenon e-n cross section","category":"page"},{"location":"reference/collisions/#ElectronNeutralLookup","page":"Collisions and reactions","title":"ElectronNeutralLookup","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Like IonizationLookup and ExcitationLookup, this reads a table of reaction rate coefficient vs energy from a file either in the HallThruster.jl reactions directory or in a user-provided directory. The interface and usage is identical to that of the other two lookup models, with the exception that since these collisions do not have an electron energy loss associated with them, we do not need to supply an energy in the first line of the files. Thus, the first few lines of elastic_Kr.dat are:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Energy (eV)\tRate coefficient (m3/s)\n1.0\t1.7652019589294465e-14\n2.0\t6.286806105711669e-14\n3.0\t1.260621740782443e-13\n4.0\t1.879916985413993e-13\n5.0\t2.421697883866546e-13\n6.0\t2.878523500134384e-13\n7.0\t3.2602160860803316e-13","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Naming is similarly simple, with HallThruster.jl looking for files named as follows","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"elastic_$(species).dat","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Since electron-ion collisions are not handled via the ReactionModel interface, species with charge states greater than 0, if provided, are ignored.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Once a rate coefficient k_en(epsilon) is computed, the electron-neutral collision frequency is simply","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"nu_en = n_n k_en(epsilon)","category":"page"},{"location":"reference/collisions/#LandmarkElectronNeutral","page":"Collisions and reactions","title":"LandmarkElectronNeutral","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"In this model, as in the LANDMARK benchmark, the electron-neutral collision rate coefficient has a constant value of k_en = 25times 10^-13.","category":"page"},{"location":"reference/collisions/#GKElectronNeutral","page":"Collisions and reactions","title":"GKElectronNeutral","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This uses a fit to the Xenon average collision cross section as a function of electron temperature taken from Goebel and Katz, Fundamentals of Electric Propulsion (page 58):","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"beginaligned\nnu_en = sigma_en(T_e) n_n sqrtfrac8 e T_epi m_e \nsigma_en(T_e) = 66times 10^-19 leftfracfracT_e4 - 011 + left(fracT_e4right)^16right textrmm^2\nendaligned","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Here, T_e is in eV.","category":"page"},{"location":"reference/collisions/#Electron-ion-collisions","page":"Collisions and reactions","title":"Electron-ion collisions","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Unlike the above types of collisions, electron-ion colulombic collisions are not strongly dependent on the type of gas, as the interaction distance is much larger than the atomic radius. They are thus handled via a simple Boolean flag in the Config struct: electron_ion_collisions = true or electron_ion_collisions = false. These are computed using the classical formulae (see NRL Plasma Formulary, pg. 33):","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"nu_ei = 29 times 10^-6 Z^2 n_e T_e^-32 lnLambda","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Here, Z is the ion charge state, n_e is the plasma density in m^-3 and T_e is the electron temperature in eV. In the above expression, lnLambda is the well-known Coulomb logarithm, given by","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"beginaligned\nlnLambda = 23 - frac12lnleft(10^-6  Z^2 n_e T_e^-3right)  T_e  10 Z^2 textrm eV \nlnLambda = 24 - frac12lnleft(10^-6  n_e T_e^-2right)  T_e  10  Z^2 textrm eV\nendaligned","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"For plasmas containing multiple charge states, we compute the number-averaged charge state langle Zrangle and use that in the above formula:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"langle Zrangle equiv left(sum_s Z_s n_sright)  n_e","category":"page"},{"location":"reference/collisions/#Implementing-your-own-collisions","page":"Collisions and reactions","title":"Implementing your own collisions","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"ElectronNeutralModel, ExcitationModel and IonizationModel are all subtypes of ReactionModel.  Users may specify their own IonizationModel, ElectronNeutralModel, or ExcitationModel by implementing a few key functions required by the ReactionModel interface. Let's say we wanted to implement our own ionization model, called MyIonizationModel, we would first define our struct as a subtype of HallThruster.IonizationModel, along with any fields we might want:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"struct MyIonizationModel <: HallThruster.IonizationModel\n\t# any fields you might want\nend","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"If we were defining an ExcitationModel, we would instead subtype HallThruster.ExcitationModel, and if we were defining a model for electron-neutral elastic scattering, we would subtype ElectronNeutralModel. Next, we need to define a few helper methods.","category":"page"},{"location":"reference/collisions/#supported_gases(::ReactionModel)::Vector{Gas}","page":"Collisions and reactions","title":"supported_gases(::ReactionModel)::Vector{Gas}","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This method must return a vector of Gas objects. If not overwritten, this method returns Gas[], which signifies that there are no restrictions on what type of gas works with this method. This is useful for IonizationLookup, which can in principle work for any gas, but not so much for LandmarkLookup, which is Xenon specific. Specifying which gases your model is valid for lets HallThruster.jl check at run time that user-provided propellant works with the provided model, preventing it from silently computing a bad result without the user's knowledge.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Let's say our model works exclusively with Bismuth","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"import HallThruster: supported_gases\n\nHallThruster.supported_gases(::MyIonizationModel) = [HallThruster.Bismuth]","category":"page"},{"location":"reference/collisions/#maximum_charge_state(::ReactionModel)::Int","page":"Collisions and reactions","title":"maximum_charge_state(::ReactionModel)::Int","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"This method returns an integer corresponding to the maximum allowed charge state. By default, this is zero, indicating that our method can work with any charge state. However, to avoid mistakes down the line, it is best to define this, unless we're defining an ElectronNeutralModel. In our case, let's just work with singly-charged Bismuth.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"import HallThruster: maximum_charge_state\n\nHallThruster.maximum_charge_state(::MyIonizationModel) = 1","category":"page"},{"location":"reference/collisions/#load_reactions(model::ReactionModel,-species::Vector{Species})","page":"Collisions and reactions","title":"load_reactions(model::ReactionModel, species::Vector{Species})","text":"","category":"section"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"load_reactions takes our model along with a vector of Species (generated using the propellant and ncharge fields in the user-provided Config) and returns a vector of IonizationReaction or ExcitationReaction. If you are not using a lookup table for this purpose, the rate_coeffs field of these structs can be left empty. In that case you also need to define the rate_coeff function, as by default that looks for a lookup table in the reaction struct.","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"Let's say our ionization rate coefficient is","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"k_iz(epsilon) = 4times 10^-20 expleft(frac-73frac23 epsilonright)sqrtfrac8 (frac23epsilon)pi m_e","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"We would implement this as so:","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"import HallThruster: e, me, load_reactions, rate_coefficient\n\nfunction rate_coeff(::MyIonizationModel, ::Reaction, energy::Float64)\n    Tev = 2/3 * energy\n    return 4e-20 * exp(-7.3 / Tev) * sqrt(8 * Tev / pi / me)\nend\n\nfunction load_reactions(::MyIonizationModel, species)\n    rxn = IonizationReaction(\n    \tenergy = -7.3,\n        #=\n        Since we defined maximum_charge_state and supported_species, we know that\n        species[1] will be Bi and species[2] will be Bi+. Otherwise, an error would have\n        been thrown before this point. Without these methods, we would need have logic \t\t\t \thandling whichever species get passed to the function.\n        =#\n        reactant = species[1],\n        product = species[2],\n        # Empty lookup table, as we will not be using it\n        rate_coeff = Float64[]\n    )\n    return rxn\nend","category":"page"},{"location":"reference/collisions/","page":"Collisions and reactions","title":"Collisions and reactions","text":"The above advice works identically for defining your own ExcitationModel, with the sole exception that ExcitationReaction objects do not have a product field. Similarly, we can define our own ElectronNeutralModel, noting that ElasticCollisions do not have an energy field or a product field. We would also not need to define maximum_charge_state for an ElectronNeutralModel.","category":"page"},{"location":"howto/new_anom_model/#Adding-an-anomalous-transport-model","page":"Implement an anomalous transport model","title":"Adding an anomalous transport model","text":"","category":"section"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"CurrentModule = HallThruster","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Users of HallThruster may define their own models by defining a custom subtype of AnomalousTransportModel and a few methods.","category":"page"},{"location":"howto/new_anom_model/#Static-transport-model","page":"Implement an anomalous transport model","title":"Static transport model","text":"","category":"section"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Suppose we want to implement nu_AN = beta omega_ce (classic Bohm diffusion). This is a fixed anomalous transport model and does not change as the simulation progresses. We would first define our type:","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"using HallThruster\n\nstruct BohmDiffusion <: AnomalousTransportModel\n    β::Float64\nend","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"We then need to define the function which computes the anomalous transport in each cell. This is a mutating function which takes two arguments: the vector of anomalous collision frequency values to be updated, and the solver params.","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"function (model::BohmDiffusion)(νan, params, config)\n    e = HallThruster.e\n    me = HallThruster.me\n    B = params.cache.B\n\n    for i in eachindex(νan)\n        ωce = e * B[i] / me\n        νan[i] = model.β * ωce\n    end\n\n    return νan\nend","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"We can now set anom_model = BohmDiffusion in our Config struct.","category":"page"},{"location":"howto/new_anom_model/#Time-varying-transport-model","page":"Implement an anomalous transport model","title":"Time-varying transport model","text":"","category":"section"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Bohm diffusion is a very simple transport model that does not change over time. More complex, physics-based models may depend self-consistently on local plasma properties and evaolve in time","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Let's compute an anomalous transport that depends on energy density of electrostatic waves in the plasma. This model derives from Lafleur, Chabert, and Balruud [1] and has the following form:","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"beginaligned\nnu_AN = K fracnabla cdot mathbfu_i Wm_e n_e c_s v_de\nendaligned","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"In this expression, K is a tunable coefficient, u_i is the ion velocity, W = n_e k_B T_e is the wave energy density, m_e is the electron mass, n_e is the electron number density, c_s is the ion sound speed, and v_de is the electron azimuthal drift speed. Let's say we want to save the wave energy density in addition to the anomalous collision frequency, for later analysis. We begin by defining the model:","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"struct LafleurModel <: AnomalousTransportModel\n    K::Float64\nend","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Next, we add a method to the num_anom_variables function.  This function is part of the Anomalous transport interface and tells HallThruster how many extra arrays we need to allocate during simulation initializion. These arrays store one value per cell. Since we want to save the wave energy density, we need 1 anomalous transport variable.","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"num_anom_variables(::LafleurModel) = 1","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Now, we define the behavior of the model in a function, just as we did for Bohm. Since the model is based on assuming the wave energy convects with the ions, we will use upwind differencing for the gradient.","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"function (model::LafleurModel)(νan, params, config)\n    (;grid, cache) = params\n    z = grid.cell_centers\n    mi = config.propellant.m\n    K = model.K\n    e = HallThruster.e\n    me = HallThruster.me\n    (;ne, Tev, ue, ui, νe, anom_variables) = cache\n\n    ncells = length(νan)\n\n    for i in 2:ncells-1\n\n        W = e * ne[i] * Tev[i]\n        Hall_param = e * B[i] / me / νe[i]\n        vde = Hall_param * ue[i]\n        cs = sqrt(e * Tev[i] / mi)\n\n        # Upwind differencing of gradient term\n        if ui > 0\n            dz = z[i] - z[i-1]\n            W_left = e * ne[i-1] * Tev[i-1]\n            grad_ui_W = (ui[1, i] * W[i] - ui[1, i-1] * W_left) / dz\n        else\n            dz = z[i+1] - z[i]\n            W_right = e * ne[i+1] * Tev[i+1]\n            grad_ui_W = (ui[1, i+1] * W_right - ui[i] * W[i]) / dz\n        end\n\n        # Save W to cache.anom_variables[1]\n        anom_variables[1][i] = W\n\n        # Return anomalous collision frequency\n        νan[i] = abs(K * grad_ui_W / (me * cs * vde * ne))\n    end\n\n    # Neumann boundary condition for all variables\n    anom_variables[1][1] = anom_variables[1][2]\n    anom_variables[1][end] = anom_variables[1][end-1]\n    νan[1] = νan[2]\n    νan[end] = νan[end-1]\n\n    return νan\nend","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Once the solution has been generated by calling run_simulation with appropriate arguments, we can retrieve the wave energy density at frame i as","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"W = solution.frames[i].anom_variables[1]","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Models like this can become unstable quickly, so HallThruster also supports the ability to smooth the anomalous transport. This can be accomplished using the anom_smoothing_iters key of the Config, which determines the number of times a smoothing filter will be applied to the results of the transport calculation.","category":"page"},{"location":"howto/new_anom_model/#Advanced-usage:-implementing-additional-PDEs-for-anomalous-transport","page":"Implement an anomalous transport model","title":"Advanced usage: implementing additional PDEs for anomalous transport","text":"","category":"section"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"The most complex anomalous transport might require the solution of one or more additional PDEs. This can be accomplished using the same machinery we used above. We demonstrate this by solving the scalar advection equation using first-order upwind differencing in space and forward Euler integration in time, with periodic boundary conditions. The scalar advection equation is given by:","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"beginaligned\nfracpartial upartial t + a fracpartial upartial x = 0\nendaligned","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"To begin, we define the model struct and the number of variables we need.","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"using HallThruster, Plots\n\nstruct ScalarAdvection{F} <: HallThruster.AnomalousTransportModel\n    advection_velocity::Float64  # Advection advection_velocity\n    initializer::F  # Initialization function\nend\n\n# Save two auxilliary variables\n#   1) Advected quantity u\n#   2) gradient of advected quantity (du/dz)\nHallThruster.num_anom_variables(::ScalarAdvection) = 2","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"Next, we define the model function:","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"function (model::ScalarAdvection)(νan, params, config)\n    ncells = length(νan)\n\n    # Extract variables from params\n    cache = params.cache\n    z = params.z_cell\n    u = cache.anom_variables[1]\n    du_dz = cache.anom_variables[2]\n    a = model.advection_velocity\n    dt = params.dt\n\n    if params.iteration[] < 1\n        # Initialize\n        model.initializer(u, z)\n    else\n        for i in eachindex(νan)\n            # Setup for periodic boundary conditions\n            if i == 1\n                i_minus_1 = ncells\n                dz_minus = z[2] - z[1]\n            else\n                i_minus_1 = i - 1\n                dz_minus = z[i] - z[i-1]\n            end\n\n            if i == ncells\n                i_plus_1 = 1\n                dz_plus = z[2] - z[1]\n            else\n                i_plus_1 = i + 1\n                dz_plus = z[i+1] - z[i]\n            end\n\n            # Update gradient using upwind differencing\n            if a > 0\n                du_dz[i] = (u[i] - u[i_minus_1]) / dz_minus\n            else\n                du_dz[i] = (u[i_plus_1] - u[i]) / dz_plus\n            end\n        end\n\n        # Update advected quantity\n        for i in eachindex(νan)\n            u[i] -= a * du_dz[i] * dt\n        end\n    end\n\n    # Return a two-zone bohm anomalous transport result,\n    # since we don't really care about the anomalous transport in this case.\n    # In a more general case, you would set `νan` based on the results of the PDE\n    return HallThruster.TwoZoneBohm(1/160, 1/16)(νan, params)\nend","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"And that's it! Now all there is to do is define our simulation parameters and run!","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"# Set up config\nadvection_velocity = 1e5\nL = 0.08\n\nconfig = HallThruster.Config(\n    domain = (0.0, L),\n    anom_model = ScalarAdvection(advection_velocity, initializer),\n    thruster = HallThruster.SPT_100,\n    discharge_voltage = 300.0,\n    anode_mass_flow_rate = 5e-6\n)\n\n# Define dt such that CFL condition is obeyed for scalar advection\n# Note -- this CFL number is different from the CFL number used by `HallThruster`\ndx = L / ncells\nCFL = 0.9\ndt = min(1e-8, dx * CFL / advection_velocity)\nnsteps = 1000\nduration = nsteps * dt\nsimparams = SimParams(\n    adaptive = false,\n    nsave = nsteps,\n    grid = HallThruster.EvenGrid(200)\n    dt = dt, duration = duration,\n)\nncells = 200\n\n# Run simulation\nsolution = HallThruster.run_simulation(config, simparams)\n\n# Extract variables from solution\nz = solution[:z]\nu = [frame.anom_variables[1] for frame in solution.frames]","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"We can now use a plotting package of our choice to visualize the results to make sure everything worked well. In this case we will use Plots.","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"using Plots\n\n# Time needed to transit the domain\nt_transit = L / advection_velocity\n\n# Number of periods\nnum_periods = floor(Int, nsteps * dt / t_transit)\n\n# Plot results\np = plot(; framestyle = :box, xlabel = \"x\", ylabel = \"u\", title = \"First order upwind for scalar advection\")\nfor i in 0:num_periods\n    index = round(Int, i * t_transit / dt) + 1\n    plot!(\n        p, z, u[index], label = \"After $i periods\",\n        linecolor = cgrad(:turbo, num_periods + 1, categorical = true)[i+1]\n    )\nend\ndisplay(p)","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"(Image: )","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"This looks correct! In this case, we haven't coupled our PDE solution to the anomalous transport, but one could easily do this. In the same way, systems of two, three, or more coupled PDEs can be solved and related to the anomalous collision frequency.","category":"page"},{"location":"howto/new_anom_model/","page":"Implement an anomalous transport model","title":"Implement an anomalous transport model","text":"T. Lafleur, S. D. Baalrud and P. Chabert. Theory for the anomalous electron transport in Hall effect thrusters. II. Kinetic model. Physics of Plasmas 23, 11101 (2016).\n\n\n\n","category":"page"},{"location":"howto/new_propellant/#Adding-a-new-propellant","page":"Add a new propellant","title":"Adding a new propellant","text":"","category":"section"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"note: Note\nHallThruster only supports monatomic propellants at this time. Support for molecular propellants, such as iodine or carbon dioxide, may come in a future release.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"HallThruster allows users to add new propellants beyond those provided by the code. For instance, if you wanted to implement Neon, you first create an appropriate Gas, like so:","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"using HallThruster: HallThruster as het\n\nNeon = het.Gas(\"Neon\", \"Ne\"; γ = 5/3, M = 20.1797)","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"Next, you need to find some reactions. Ionization reactions are mandatory, while elastic collisions and excitation reactions are optional. We recommend you check the LXCat database for appropriate cross sections.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"You must then convert cross sections must be converted into ionization rate coefficients by integrating over a Maxwellian electron energy distribution for a number of energies. You can do this manually, or use a tool like BOLSIG+ to do it for you.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"Then, you must place the resulting table of electron energy versus rate coefficient in an appropriately-named file. The expected formats for these filenames and files can be seen by examining the tables for the built-in propellants.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"If you want to run a simulation with Z as the maximum charge state, HallThruster requires at least one reaction containing each species, including the mandatory first ionization reaction (i.e. neutral -> singly-charged ion). For example, for Neon with ncharge = 3, the following ionization reaction sets would suffice.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"[ionization_Ne_Ne+.dat, ionization_Ne_Ne2+.dat, ionization_Ne_Ne3+.dat]\n[ionization_Ne_Ne+.dat, ionization_Ne+_Ne2+.dat, ionization_Ne2+_Ne3+.dat]","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"While excitation reactions (excitation_Ne.dat) and electron-neutral elastic collisions (elastic_Ne.dat) are optional, they are strongly encouraged to improve the physical fidelity of your simulations.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"With these files created, you can now run a simulation using Neon as a propellant by passing Neon to Config, along with a list of directories that HallThruster should search in order to find your reaction files.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"using HallThruster: HallThruster as het\n\nNeon = het.Gas(\"Neon\", \"Ne\"; γ = 5/3, M = 20.1797)\n\nconfig = het.Config(\n    propellant = Neon,\n    reaction_rate_directories = [\"~/reactions/neon_reaction_dir\"]\n    ... # other arguments\n)\n\nsimparams = het.SimParams(...)\n\nsolution = het.run_simulation(config, sim_params)","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"These directories will be checked, in order, before the HallThruster.jl directory is checked. For example, if we passed reaction_rate_directories = [\"reactions\", \"more_reactions\"], the code will first look in \"reactions\", then in \"more_reactions\", before finally checking \"HallThruster.jl/reactions\". An error will be emitted if the reaction rate files cannot be found.","category":"page"},{"location":"howto/new_propellant/","page":"Add a new propellant","title":"Add a new propellant","text":"Note that you may need to tweak other settings in the Config and SimParams struct to get simulations using non-built-in propellants working well, as thrusters running on these propellants may exhibt very different stability and physical characteristics than the default parameters were designed to handle.","category":"page"},{"location":"reference/wall_loss_models/#Wall-Loss-Models","page":"Wall loss models","title":"Wall Loss Models","text":"","category":"section"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"HallThruster.jl allows you to choose from three different wall loss models. They approximate the electron energy lost to the thruster walls in radial direction. As the computational axis of the 1D code is axially in the thruster, the wall loss is not directly resolved by the fluid and applied in each cell as an electron energy loss term. ","category":"page"},{"location":"reference/wall_loss_models/#Background","page":"Wall loss models","title":"Background","text":"","category":"section"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"The core of the wall loss models in HallThruster.jl is the abstract type WallLossModel. It has three children: NoWallLosses, ConstantSheathPotential, and WallSheath. ConstantSheathPotential has three fields. A wall sheath_potential to be set by the user, and an inner_loss_coeff and outer_loss_coeff which allow to scale the energy loss inside vs. outside the thruster channel. WallSheath has two field: material, which is of type WallMaterial and includes information about secondary electron emission yields, and α, which is a constant wall loss scaling coefficient (values around 0.1-0.2 are good usually, but this may need to be calibrated against some data).","category":"page"},{"location":"reference/wall_loss_models/#Provided-wall-loss-models","page":"Wall loss models","title":"Provided wall loss models","text":"","category":"section"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"HallThruster.jl provides three models out of the box. These are","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"Model Supported species Description\nNoWallLosses Any Ignores electron energy losses to the walls. May cause numerical issues.\nConstantSheathPotential Any Employs a simple sheath energy loss model with constant sheath potential, based on the electron Boltzmann equation for electron density in the sheath as a function of electron temperature. Uses constants to scale losses inside and outside the thruster. See also JP Boeuf, Low frequency oscillations in a stationary plasma thruster, Journal of Applied Physics 84, 3541, 1998 and Landmark study\nWallSheath Any Conceputally similar loss model as ConstantSheathPotential, but evaluates constants and sheath potential given in the previously mentioned using approximations. We compute the power loss to the walls as","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"    P_w = nu_ew(2 T_ev - phi_s)","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"where nu_ew is the electron wall collision frequency, T_ev is the electron temperature in electron-volts, and phi_s is the wall sheath potential in volts. The sheath potential is computed as:","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"phi_w = T_ev lnleft(1 - gamma) sqrtfracm_i2pi m_eright","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"Here, gamma is the secondary electron emission coefficient, which is computed according to the choice of WallMaterial. For a plasma with only once charge state, the electron-wall collision frequency is:","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"nu_ew = frach1 - gammasqrtfrace T_eVm_ifrac1R_o - R_i","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"where R_o and R_i are the channel inner radius and outer radii respectively, and h = n_wall  n_e is the edge-to-center density ratio. This ratio is around 0.5 by default (c.f https://iopscience.iop.org/article/10.1088/0963-0252/24/2/025017), but can be changed by modifying the alpha parameter of the WallSheath model:","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"h = frac086sqrt3 alpha","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"In the plume, this ratio can be modified further by setting the electron_plume_loss_scale parameter (here called beta):","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"h = frac086sqrt3 alpha beta","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"For multiply-charged plasmas, the ion currents of each species are first computed as:","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"j_iwZ = h Z e n_iZ sqrtfracZ e T_eVm_i","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"Then, the electron wall current minus the secondary electron current are equal to the total ion wall current:","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"(1 - gamma) j_ew = j_iw = sum_Z j_iw Z","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"Lastly, we compute the electron-wall collision frequency as","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"nu_ew = fracj_ewe n_e frac1R_o - R_i","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"The ion current of each species is also used to compute ion wall losses if ion_wall_losses is set to true in config. Ions are assumed to recombine at the walls and the flux is re-injected as neutrals.","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"dotn_iw Z = -fracj_iw Zefrac1R_o - R_i","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"dotn_nw Z = -sum_Z dotn_iw Z","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"If thruster.shielded is true, the electron temperature at the walls is assumed to be equal to the electron temperature at the anode when inside the channel, see Thrusters for the option.","category":"page"},{"location":"reference/wall_loss_models/#Impact-of-magnetic-shielding","page":"Wall loss models","title":"Impact of magnetic shielding","text":"","category":"section"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"The effect on magnetic shielding on the electron energy can be seen below. Compared are time-averaged electron energy profiles for a Xenon SPT-100 type thruster using Boron Nitride walls.","category":"page"},{"location":"reference/wall_loss_models/","page":"Wall loss models","title":"Wall loss models","text":"(Image: unshielded_vs_shielded)","category":"page"},{"location":"reference/propellants/#Propellants","page":"Propellants","title":"Propellants","text":"","category":"section"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"HallThruster implements several common Hall thruster propellants, and makes it easy to implement your own.","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Propellants in HallThruster are instances of the Gas struct, which contains information about the atomic and thermodynamic properties of a gaseous substance.","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Many of these properties are functions of the others, so HallThruster provides a convenience constructor Gas(name, short_name, γ, M) which will compute the rest of the properties automatically.","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Gas\nGas(name, short_name; γ, M)","category":"page"},{"location":"reference/propellants/#HallThruster.Gas","page":"Propellants","title":"HallThruster.Gas","text":"struct Gas\n\nA chemical element in the gaseous state. Container for element properties used in fluid computations.\n\nFields\n\nname::String: Full name of gas (i.e. Xenon)\nshort_name::String: Short name/symbol (i.e. Xe for Xenon)\nγ::Float64: Specific heat ratio / adiabatic index\nM::Float64: Molar mass (grams/mol) or atomic mass units\nm::Float64: Mass of atom in kg\ncp::Float64: Specific heat at constant pressure\ncv::Float64: Specific heat at constant volume\nR::Float64: Gas constant\n\n\n\n\n\n","category":"type"},{"location":"reference/propellants/#HallThruster.Gas-Tuple{Any, Any}","page":"Propellants","title":"HallThruster.Gas","text":"Gas(name, short_name; γ, M) -> Gas\n\nInstantiate a new Gas, providing a name, short name, the adiabatic index, and the molar mass. Other gas properties, including gas constant, specific heats at constant pressure/volume, and mass of atom/molecule in kg will are then computed.\n\njulia> Gas(\"Xenon\", \"Xe\", γ = 5/3, M = 83.798)\nXenon\n\n\n\n\n\n","category":"method"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Gases can become ionized to produce Species, which are structs containing a Gas and a charge state, Z. HallThruster uses the ncharge field of Config (see Configuration) to construct a list of Species, which it then uses to load reactions from the default directory and from any user-provided directories.","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Species\nSpecies(element::Gas, Z::Int)","category":"page"},{"location":"reference/propellants/#HallThruster.Species","page":"Propellants","title":"HallThruster.Species","text":"struct Species\n\nRepresents a gas with a specific charge state. In a plasma, different ionization states of the same gas may coexist, so we need to be able to differentiate between these.\n\nFields\n\nelement::HallThruster.Gas: The gas that forms the base of the species\nZ::Int64: The charge state of the species, i.e. Z = 1 for a singly-charged species\nsymbol::Symbol: The symbol of the species, i.e. Symbol(Xe+) for Species(Xenon, 1)\n\njulia> Species(Xenon, 0)\nXe\n\njulia> Species(Xenon, 1)\nXe+\n\njulia> Species(Xenon, 3)\nXe3+\n\n\n\n\n\n","category":"type"},{"location":"reference/propellants/#HallThruster.Species-Tuple{HallThruster.Gas, Int64}","page":"Propellants","title":"HallThruster.Species","text":"Species(element::Gas, Z::Int) -> Species\n\nConstruct a Species from a Gas and a charge state. You can also use the (::Gas)(Z) convenience constructor like so.\n\njulia> Xenon(0) == Species(Xenon, 0)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/propellants/#Built-in-propellants","page":"Propellants","title":"Built-in propellants","text":"","category":"section"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"HallThruster provides Gas definitions and full sets of reaction rate coefficients for the following gases","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Xenon\nKrypton","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Gas definitions and partial rate coefficients are available for these gases.","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Argon: Single, double, and triple ionization from neutral argon. No elastic, excitation, or stepwise ionizations are included at present.\nBismuth\nMercury","category":"page"},{"location":"reference/propellants/","page":"Propellants","title":"Propellants","text":"Users wishing to implement their own propellant should read Adding a new propellant.","category":"page"},{"location":"reference/thrusters/#Thrusters","page":"Thrusters","title":"Thrusters","text":"","category":"section"},{"location":"reference/thrusters/","page":"Thrusters","title":"Thrusters","text":"CurrentModule = HallThruster","category":"page"},{"location":"reference/thrusters/#Built-in-thrusters","page":"Thrusters","title":"Built-in thrusters","text":"","category":"section"},{"location":"reference/thrusters/","page":"Thrusters","title":"Thrusters","text":"SPT_100\nspt100_geometry\nspt100_analytic_field","category":"page"},{"location":"reference/thrusters/#HallThruster.SPT_100","page":"Thrusters","title":"HallThruster.SPT_100","text":"SPT-100\n\nA Thruster definition for the SPT-100 Hall thruster\n\nDefinition\n\nconst SPT_100 = Thruster(;\n    name = \"SPT-100\",\n    geometry = spt100_geometry,\n    magnetic_field = spt100_analytic_field(),\n    shielded = false,\n)\n\n\n\n\n\n","category":"constant"},{"location":"reference/thrusters/#HallThruster.spt100_geometry","page":"Thrusters","title":"HallThruster.spt100_geometry","text":"spt_100_geometry\n\nThe geometry of the SPT-100 Hall thruster\n\nconst spt100_geometry = Geometry1D(;\n    inner_radius = 0.0345, \n    outer_radius = 0.05,\n    channel_length = 0.025,\n)\n\n\n\n\n\n","category":"constant"},{"location":"reference/thrusters/#HallThruster.spt100_analytic_field","page":"Thrusters","title":"HallThruster.spt100_analytic_field","text":"spt100_analytic_field()\n\n\nAn analytic magnetic field similar to that of an SPT-100 thruster. Derived from the Landmark benchmark.\n\n\n\n\n\n","category":"function"},{"location":"reference/thrusters/#Types","page":"Thrusters","title":"Types","text":"","category":"section"},{"location":"reference/thrusters/","page":"Thrusters","title":"Thrusters","text":"Thruster\nGeometry1D\nMagneticField","category":"page"},{"location":"reference/thrusters/#HallThruster.Thruster","page":"Thrusters","title":"HallThruster.Thruster","text":"struct Thruster\n\nDefines a Hall thruster from a name, geometry, magnetic field. The thruster may also be shielded, in which case the wall electron temperature is assumed to be equal to the anode electron temperature inside the discharge channel.\n\nFields\n\nname::String: Name of the thruster. Not used during the simulation, but useful for certain cases.\n\ngeometry::HallThruster.Geometry1D: The thruster geometry\n\nmagnetic_field::HallThruster.MagneticField: Contains a magnetic field at discrete axial locations\n\nshielded::Bool: Whether the thruster is magnetically-shielded\n\n\n\n\n\n","category":"type"},{"location":"reference/thrusters/#HallThruster.Geometry1D","page":"Thrusters","title":"HallThruster.Geometry1D","text":"struct Geometry1D\n\nDescribes the geometry of a Hall thruster discharge channel.\n\nFields\n\nchannel_length::Float64: The discharge channel length, in meters\n\ninner_radius::Float64: The inner radius of the discharge channel, in meters\n\nouter_radius::Float64: The outer radius of the discharge channel, in meters\n\nchannel_area::Float64: The discharge channel cross-sectional area, computed from inner_radius and outer_radius\n\n\n\n\n\n","category":"type"},{"location":"reference/thrusters/#HallThruster.MagneticField","page":"Thrusters","title":"HallThruster.MagneticField","text":"mutable struct MagneticField\n\nSpecifies the radial magnetic field of a Hall thruster, measured along channel centerline.\n\nFields\n\nfile::String: The file where magnetic field information can be found. Can be left empty if z and B are explicitly specified.\n\nz::Vector{Float64}: The axial coordinates at which the magnetic field is known, in meters.\n\nB::Vector{Float64}: The magnetic field at each point in z, measured in Teslas.\n\n\n\n\n\n","category":"type"},{"location":"reference/thrusters/#Functions","page":"Thrusters","title":"Functions","text":"","category":"section"},{"location":"reference/thrusters/","page":"Thrusters","title":"Thrusters","text":"load_magnetic_field\nload_magnetic_field!","category":"page"},{"location":"reference/thrusters/#HallThruster.load_magnetic_field","page":"Thrusters","title":"HallThruster.load_magnetic_field","text":"load_magnetic_field(\n    file::String;\n    include_dirs\n) -> HallThruster.MagneticField\n\n\nGiven a path to a file, loads a MagneticField from the data in that file. Looks in the present working directory and any additional directories passed to include_dirs.\n\n\n\n\n\n","category":"function"},{"location":"reference/thrusters/#HallThruster.load_magnetic_field!","page":"Thrusters","title":"HallThruster.load_magnetic_field!","text":"load_magnetic_field!(\n    magnetic_field::HallThruster.MagneticField;\n    include_dirs\n)\n\n\nGiven a magnetic field field with empty z or B fields, looks for a magnetic field at field.file. If one is found in the present directory or in any of the provided include_dirs, sets z and B accordingly. Throws an ArgumentError if one is not found.\n\n\n\n\n\n","category":"function"},{"location":"howto/json/#Use-JSON-for-input-and-output","page":"Use JSON input and output","title":"Use JSON for input and output","text":"","category":"section"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"CurrentModule = HallThruster","category":"page"},{"location":"howto/json/#Running-simulations-from-JSON-input.","page":"Use JSON input and output","title":"Running simulations from JSON input.","text":"","category":"section"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"In addition to the usual way of running simulations using a Config and SimParams, HallThruster supports the use of JSON for input and output. This can be achieved by calling run_simulation(\"input.json\"), where \"input.json\" could be any json file. The contents of this file should be laid out in one of two ways. The first way has up to three keys – two mandatory (\"config\" and \"simulation\") and one optional (\"postprocess\"). These exactly mirror the Config, SimParams, and Postprocess structs that are normally passed to run_simulation and should be relatively self-explanatory.","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"Below, we show an example of this type of JSON input.","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"{\n    \"config\": {\n        \"thruster\": {\n            \"name\": \"SPT-100\",\n            \"geometry\": { \"inner_radius\": 0.0345, \"outer_radius\": 0.05, \"channel_length\": 0.025 },\n            \"magnetic_field\": { file = \"bfield_spt100.csv\" }\n        },\n        \"propellant\": \"Krypton\",\n        \"discharge_voltage\": 300.0,\n        \"anode_mass_flow_rate\": 5e-6,\n        \"domain\": [0.0, 0.08],\n        \"anom_model\": {\n            \"type\": \"TwoZoneBohm\",\n            \"c1\": 0.00625,\n            \"c2\": 0.0625\n        }\n    },\n    \"simulation\": {\n        \"adaptive\": true,\n        \"dt\": 5e-9,\n        \"grid\": {\n            \"type\": \"EvenGrid\",\n            \"num_cells\": 200,\n        },\n        \"duration\": 1e-3,\n        \"num_save\": 1000,\n    },\n    \"postprocess\": {\n        \"output_file\": \"output.json\"\n        \"save_time_resolved\": false,\n        \"average_start_time\": 5e-4\n    }\n}","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"In the second way, the JSON file has a top level field input, with members config, simulation, and (optionally) postprocess, e.g.","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"{\n    \"input\": {\n        \"config\": {...},\n        \"simulation\": {...},\n        \"postprocess\": {...}\n    }\n}","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"where the contents of these keys are exactly the same as in the first method.","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"In both cases, the field names and types of these inputs are exactly the same as in the corresponding HallThruster types. Note the \"type\" field for config.anom_model and simulation.grid, which precedes the other fields for that type. This pattern is also used for config.conductivity_model and config.wall_loss_model, should you wish to provide those. Note that custom anomalous transport models and propellants are not supported using the JSON interface at this time.","category":"page"},{"location":"howto/json/#Writing-output-files","page":"Use JSON input and output","title":"Writing output files","text":"","category":"section"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"If postprocess is provided and postprocess.output_file is not empty, HallThruster will write an output JSON file to that file. The output file contains two top-level fields: input and output. The input field reproduces the inputs used to run the simulation, exactly as described above. The output field has at most four fields: retcode, error, fields, and average, e.g.","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"{\n    \"input\": {...},\n    \"output\": {\n        \"retcode\": \"success\",\n        \"error\": \"\",\n        \"average\": {...},\n        \"frames\": [\n            {...}, {...}, ...\n        ]\n    }\n}","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"The output_field somewhat mirrors the Solution object. The retcode gives the simulation status (one of \"success\", \"error\", or \"failure\"). If retcode is error, the error will contain a string with the error that occurred. If postprocess.average_start_time is greater than or equal to zero, the average field contains the output of HallThruster.time_average(sol, average_start_time). Finally, if postprocess.save_time_resolved is true, then output.frames contains simulation.num_save frames.","category":"page"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"You can also manually write a Solution to a JSON file using the write_to_json function.","category":"page"},{"location":"howto/json/#Frame-format","page":"Use JSON input and output","title":"Frame format","text":"","category":"section"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"The frames in the output JSON file are laid out similarly to those in the Solution struct, with some additions. In addition to plasma properties, each frame also stores its time, as well as thrust, discharge current, and component efficiencies.","category":"page"},{"location":"howto/json/#Restarts","page":"Use JSON input and output","title":"Restarts","text":"","category":"section"},{"location":"howto/json/","page":"Use JSON input and output","title":"Use JSON input and output","text":"warning: Interface not finalized\nThe restart interface is not finalized and is subject to change before v1.0.","category":"page"},{"location":"explanation/initialization/#Initialization","page":"Initialization","title":"Initialization","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"HallThruster.jl provides sensible defaults for simulation initialization, or allows you to specify your own initial condition.","category":"page"},{"location":"explanation/initialization/#Default","page":"Initialization","title":"Default","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The default is DefaultInitialization(), which initializes the solution domain as described in the following sections. Below, z_0 and z_N are domain[1] and domain[2], as passed into the Config object (see Configuration), L_ch and A_ch are config.thruster.geometry.channel_length and config.thruster.geometry.channel_area, respectively, and dotm is config.anode_mass_flow_rate.","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The DefaultInitialization has parameters max_electron_temperature, min_ion_density, and max_ion_density, which can be used to scale the default initialized. These default to config.discharge_voltage/10, 2e17, and 1e18, respectively.","category":"page"},{"location":"explanation/initialization/#Ion-densities","page":"Initialization","title":"Ion densities","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The ion densities are Gaussian with a constant offset and a scaling factor proportional to the mass flow rate and discharge voltage.  For ions with charge 1, the density is","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"rho_i = rho_min m_i sqrtfracV_d300fracdotm5times10^-6left(1 + fracrho_maxrho_min expleft-left(fracz - z_0 - L_ch2L_ch3right)^2rightright)","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"For ions with charge Z, the density is assumed to scale as","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"rho_i_Z = fracrho_i _Z=1Z^2","category":"page"},{"location":"explanation/initialization/#Ion-velocities","page":"Initialization","title":"Ion velocities","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"Ions are initialized with the Bohm velocity at the anode. For an ion of charge Z, this is","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"u_i1 = -u_bohm =- sqrtfracZ eT_eV anodem_i","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The maximum ion velocity is determined by the discharge voltage V_d:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"u_imathrmend = u_max = sqrtfrac2 Z e  V_dm_i","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The initial ion velocity profile between the cathode and the anode is then prescribed as:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"u_i(z) = begincases\n\tu_bohm + frac23(u_max - u_bohm)left(fracz - z_0L_chright)^2  z-z_0  L_ch \n\tfrac13left(u_bohm + u_maxright)left(1 - fracz - z_0 - L_chz_N - L_chright) + u_maxleft(fracz - z_0 - L_chz_N - L_chright)  z - z_0 ge L_ch\nendcases","category":"page"},{"location":"explanation/initialization/#Neutral-density","page":"Initialization","title":"Neutral density","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The neutral density at the anode is computed in the same way as during a simulation, namely:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"rho_n anode = fracdotmu_n A_ch - sum_s fracrho_is u_is_anodeu_n","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The density at the cathode is assumed to be 1/100 that at the anode. In the domain, the neutral density has a sigmoid shape:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"rho_n(z) = frac12left(rho_nanode + rho_n cathode + (rho_n anode - rho_n cathode)tanhleft(fracz - z_0 - L_ch2L_ch  6right)right)","category":"page"},{"location":"explanation/initialization/#Electron-energy","page":"Initialization","title":"Electron energy","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"The number density is computed from the ion densities. The electron temperature is a Gaussian with height V_d  10 eV plus a linear baseline to make sure the boundary conditions are satisfied:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"T_e(z) = left(1 - fracz - z_0z_N - z_0right) T_e anode + left(fracz - z_0z_N - z_0right) T_e cathode + T_emaxexpleft-left(fracz - z_0 - L_chL_ch3right)^2right","category":"page"},{"location":"explanation/initialization/#Example","page":"Initialization","title":"Example","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"For  a simulation of the SPT-100 with V_d= 500V, three ion charge states, a a mass flow rate of 3 mg/s, an anode electron temperature of 3 eV and a cathode electron temperature of 5 eV, the initial condition looks like:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"(Image: )","category":"page"},{"location":"explanation/initialization/#Custom-initial-conditions","page":"Initialization","title":"Custom initial conditions","text":"","category":"section"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"You may define your own initial condition by creating subtypes of HallThruster.InitialCondition. Let's say for some reason we wanted to initialize every state variable in every cell to the z-location of its cell center. We might define our initialization as follows:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"using HallThruster\n\nstruct MyInitialCondition <: HallThruster.InitialCondition end;","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"We would then add a method to the initialize!(U, params, model) function as follows:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"import HallThruster.initialize!\n\nfunction HallThruster.initialize!(U, params, config, model::MyInitialCondition)\n\t(;z_cell) = params # Pull cell centers locations out of params\n    nvars = size(U, 1)\n    for (i, z) in enumerate(z_cell)\n       \tfor j in 1:nvars\n           \tU[j, i] = z_cell[i]\n        end\n    end\n    return U # optional. Since U is modified. the return value is never used, but by Julia convention we also return the mutated object.\nend;","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"We can check the behavior of our new function:","category":"page"},{"location":"explanation/initialization/","page":"Initialization","title":"Initialization","text":"# Dummy config and params\nncells = 100\nnvars = 4\nconfig = (;initial_condition = MyInitialCondition())\nz_cell = range(0, 0.05, length = ncells)\nU = zeros(nvars, ncells)\nparams = (; z_cell)\n\n# Method of initialize! which dispatches to initialize!(U, params, config.initial_condition)\n# This is what HallThruster.jl calls when initializing a simulation\nHallThruster.initialize!(U, params, config)\n\nU[1, :] == U[2, :] == U[3, :] == U[4, :] == collect(z_cell)\n\n# output\n\ntrue","category":"page"},{"location":"explanation/verification/#Verification-and-validation","page":"Validation and verification","title":"Verification and validation","text":"","category":"section"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"HallThruster is an extensively-tested code, with thousands of unit tests, in addition to order verification tests, regression tests, and validation against a known benchmark.","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"All tests can be found in the tests directory in the source code.","category":"page"},{"location":"explanation/verification/#Order-verification","page":"Validation and verification","title":"Order verification","text":"","category":"section"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"Tests can be found in the test folder, and are split in unit_tests and order_verification tests. We verify that the PDEs are discretized correctly using the Method of Manufactured Solutions (MMS) and perform order verification studies in order to ensure that the actual order of accuracy matches the expected order.","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"The method of manufactured solutions requires the injection of special source terms into HallThruster's solution procedure. These are specified in the Configuration stage, using the following keys.","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"source_neutrals\nsource_ion_continuity\nsource_ion_momentum\nsource_electron_energy","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"We use Symbolics.jl to construct these source terms automatically from the governing equations of our model. We automatically test for first and second-order spatial accuracy of all of the numerical fluxes that we use for ions, as well as for the Crank-Nicholson/implicit solver we use for the electrons.","category":"page"},{"location":"explanation/verification/#Landmark-benchmark","page":"Validation and verification","title":"Landmark benchmark","text":"","category":"section"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"In addition to the MMS studies discussed above, we also compare the results to the Landmark test cases for 1D fluid Hall Thruster discharges. Below, we compare the time-averaged output of HallThruster.jl for each of the three test cases to the expected results from Landmark. The cases differ only in the amount of electron energy lost to to radial sheaths inside the thruster.  For the purpose of verification, the boundary conditions, source terms, collision models and anomalous collision frequency has been set to match Landmark. The results shown are time-averaged, performed using 160 cells using the first-order Rusanov flux and without gradient reconstruction. ","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"Landmark energy loss term:","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"    W = nu_epsilon expleft(frac-20epsilonright)","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"where","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"    nu_epsilon=\n    begincases\n        alpha_1 times 10^7  z - z_0 leq L_ch \n        alpha_2 times 10^7  z - z_0  L_ch\n    endcases","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"and","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"epsilon = frac32 T_ev","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"In the above, L_ch refers to thruster channel length and z_0 is domain[1], or the z-location of the anode.","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"Case 1   alpha_1 = 10 alpha_2 = 10 (Image: Landmark1)","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"Case 2   alpha_1 = 05 alpha_2 = 10 (Image: Landmark2)","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"Case 3   alpha_1 = 04 alpha_2 = 10 (Image: Landmark3)","category":"page"},{"location":"explanation/verification/#Regression-tests","page":"Validation and verification","title":"Regression tests","text":"","category":"section"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"We automatically check all three landmark cases, as well as a few SPT-100 simulations, to ensure that the code performs as expected between releases. Any unforseen changes in the physics or numerics causes these tests to fail. For each case, we compare the time-averaged thrust, discharge current, component efficiencies, and peak values of electron temprature, electric field, plasma density and neutral density to expected values.  Any minor deviation from these values produces a failure.","category":"page"},{"location":"explanation/verification/","page":"Validation and verification","title":"Validation and verification","text":"These tests can be found in test/regression.","category":"page"},{"location":"reference/schemes/#Fluxes","page":"Hyperbolic schemes","title":"Fluxes","text":"","category":"section"},{"location":"reference/schemes/","page":"Hyperbolic schemes","title":"Hyperbolic schemes","text":"HallThruster.jl uses the Finite Volume method, and as such the face values of the fluxes need to be reconstructed. See Numerics for more information.","category":"page"},{"location":"reference/schemes/","page":"Hyperbolic schemes","title":"Hyperbolic schemes","text":"The fluxes F__i+frac12 and F__i-frac12 are reconstructed at the cell interfaces, and for this flux reconstruction multiple options are available. These are set using the object HyperbolicScheme consisting of fields flux, limiter, and reconstruct. Three different flux approximations are available.","category":"page"},{"location":"reference/schemes/","page":"Hyperbolic schemes","title":"Hyperbolic schemes","text":"Flux Description\nupwind Simple first order accurate flux approximation, that as a results does not distinguish between cell centered and cell average values and adapts reconstruction according to sign of advection velocity. Very diffusive. No Riemann solver or approximation.\nHLLE Approximate Riemann solver. The Harten-Lax-van Leer-Einfeldt scheme approximates a Riemann problem with three constant states. see reference. The scheme is positively-conservative if stability bounds for maximum and minimum wavespeeds are met, which makes it useful in its application with HallThruster.jl. First order accurate in space. B. Einfeldt. On godunov-type methods for gas dynamics. Journal of Computational Physics, 25:294-318, 1988.\nrusanov Approximate Riemann solver. Also known as the local Lax-Friedrich flux. Has slighlty modified choice of wave speeds. Adds viscosity to a centered flux. More diffusive than HLLE. Chi-Wang Shu, Lecture Notes: Numerical Methods for Hyperbolic Conservation Laws (AM257)","category":"page"},{"location":"reference/schemes/","page":"Hyperbolic schemes","title":"Hyperbolic schemes","text":"These flux approximations are all first order accurate in space (piecewise constant recontruction), but can be extended to piecewise linear reconstruction within a cell. To satisfy stability bounds and keep the scheme total variation diminishing (TVD), it has to be coupled with a limiter. Many limiters have been proposed, the ones implemented in HallThruster.jl are the following: koren, minmod, osher, van_albada, van_leer. If the field reconstruction is set to true, the selected limiter will be used.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"CurrentModule = HallThruster\nDocTestSetup = quote\n    using HallThruster\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"HallThruster.jl is an open-source, 1D fluid Hall thruster code written in Julia. It is developed by Thomas Marks, Paul Schedler and Declan Brick at the University of Michigan's Plasmadynamics and Electric Propulsion Laboratory and is licensed under the MIT license.","category":"page"},{"location":"#Installation","page":"Overview","title":"Installation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"To install HallThruster.jl, you must first install Julia 1.10 or above from the official Julia site. We recommend using the latest Julia release when possible. Once installed, launch Julia and type ] to enter the Pkg REPL. To install HallThruster.jl type","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"(@v1.10) pkg> add HallThruster","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This will install HallThruster.jl using Julia's package manager.","category":"page"},{"location":"#Changes","page":"Overview","title":"Changes","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"warning: Breaking release\nv0.18.0 is is a breaking release, made as part of our effort to move toward v1.0.0 in the next few months. Users may need to update their code to avoid errors.  Check out the list of changes and removals to see how to migrate your code.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A log of changes to the code from v0.18.0 onward can be found here.","category":"page"},{"location":"#Contribution","page":"Overview","title":"Contribution","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Users are welcome to suggest and implement features for the code, as well as report bugs or numerical issues they encounter. Please feel free to open an issue on this repository describing your desired change/bug-fix. Pull requests are also welcome!","category":"page"},{"location":"#Citation","page":"Overview","title":"Citation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"If you use this code in your work, please cite our publication in the Journal of Open Source Software:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"@article{Marks2023, \n  doi = {10.21105/joss.04672},\n  url = {https://doi.org/10.21105/joss.04672},\n  year = {2023},\n  publisher = {The Open Journal},\n  volume = {8}, number = {86}, pages = {4672},\n  author = {Thomas Marks and Paul Schedler and Benjamin Jorns},\n  title = {HallThruster.jl: a Julia package for 1D Hall thruster discharge simulation},\n  journal = {Journal of Open Source Software} \n} ","category":"page"},{"location":"explanation/grid_generation/#Grid-generation","page":"Grid generation","title":"Grid generation","text":"","category":"section"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"HallThruster.jl supports both regular and irregular grids. Grids are passed to the run_simulation function via the SimParams struct (see Simulation options for other parameters).","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"To create an evenly-spaced grid with ncells cells, we construct an EvenGrid","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"grid = EvenGrid(ncells)","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"Alternatively, we could produce an irregular grid using ","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"grid = UnevenGrid(ncells)","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"The UnevenGrid consists of a fine region from z = 0 to z = 15 L_ch, and a coarse region beyond that, with a smooth transition between them. The cell size in the fine region is half of that of the coarse region.","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"Both EvenGrid and UnevenGrid are HallThruster.GridSpec objects. As the name implies, these merely specify what the grid should be, but do not construct it. The actual grid is constructed just before the simulation runs.","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"To illustrate the difference between the grids, if the domain is (0 cm, 8 cm) and the thruster channel length is 2.5 cm, EvenGrid and UnevenGrid produce the following results once the grid is created. The channel exit plane is shown as a dashed red line.","category":"page"},{"location":"explanation/grid_generation/","page":"Grid generation","title":"Grid generation","text":"(Image: )","category":"page"}]
}
