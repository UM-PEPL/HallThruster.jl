<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Running and analyzing a simulation · HallThruster.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="HallThruster.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">HallThruster.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Running and analyzing a simulation</a><ul class="internal"><li><a class="tocitem" href="#Defining-geometry"><span>Defining geometry</span></a></li><li><a class="tocitem" href="#Magnetic-field"><span>Magnetic field</span></a></li><li><a class="tocitem" href="#Creating-a-Thruster"><span>Creating a Thruster</span></a></li><li><a class="tocitem" href="#Defining-a-Config"><span>Defining a Config</span></a></li><li><a class="tocitem" href="#Running-a-simulation"><span>Running a simulation</span></a></li><li><a class="tocitem" href="#Postprocessing-and-analysis"><span>Postprocessing and analysis</span></a></li></ul></li><li><a class="tocitem" href="../tutorial/">Tutorial notebook</a></li><li><a class="tocitem" href="../background/">Background</a></li><li><a class="tocitem" href="../physics/">Physics model</a></li><li><span class="tocitem">Configuration</span><ul><li><a class="tocitem" href="../config/">Configuration</a></li><li><a class="tocitem" href="../propellants/">Propellants</a></li><li><a class="tocitem" href="../initialization/">Initialization</a></li><li><a class="tocitem" href="../thrusters/">Thrusters</a></li><li><a class="tocitem" href="../fluxes/">Fluxes</a></li><li><a class="tocitem" href="../collisions/">Collisions and Reactions</a></li><li><a class="tocitem" href="../anomalous_transport/">Anomalous Transport</a></li><li><a class="tocitem" href="../wall_loss_models/">Wall Loss Models</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary Conditions</a></li><li><a class="tocitem" href="../source_terms/">User-Provided Source Terms</a></li></ul></li><li><a class="tocitem" href="../numerics/">Numerics</a></li><li><a class="tocitem" href="../verification/">Verification</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../contribution/">Contribution</a></li><li><a class="tocitem" href="../citation/">Citation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Running and analyzing a simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Running and analyzing a simulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UM-PEPL/HallThruster.jl/blob/main/docs/src/run.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Running-and-analyzing-a-simulation"><a class="docs-heading-anchor" href="#Running-and-analyzing-a-simulation">Running and analyzing a simulation</a><a id="Running-and-analyzing-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-and-analyzing-a-simulation" title="Permalink"></a></h1><p>This page will walk you through running a simulation and analyzing the output, in the process discussing many of the key features of <code>HallThruster.jl</code></p><h2 id="Defining-geometry"><a class="docs-heading-anchor" href="#Defining-geometry">Defining geometry</a><a id="Defining-geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-geometry" title="Permalink"></a></h2><p>The first thing we need to simulate a Hall thruster is geometry. Let&#39;s invent a fictional Hall thruster with a channel length of 3 cm, inner channel radius of 5 cm, and outer channel radius of 6.5 cm. To define the geometry, we create a <code>HallThruster.Geometry1D object</code>:</p><pre><code class="language-julia hljs">using HallThruster

# All units are in meters!
my_geometry = HallThruster.Geometry1D(
    inner_radius = 0.05,
    outer_radius = 0.065,
    channel_length = 0.03
)</code></pre><p>For clarity and ease of readability, you may also input dimensional numbers from the lovely <code>Unitful</code> package as shown below:</p><pre><code class="language-julia hljs">using HallThruster
using Unitful

# Units will be correctly converted!
my_geometry = HallThruster.Geometry1D(
	inner_radius = 5.0u&quot;cm&quot;,
    outer_radius = 6.5u&quot;cm&quot;,
    channel_length = 3.0u&quot;cm&quot;
)</code></pre><h2 id="Magnetic-field"><a class="docs-heading-anchor" href="#Magnetic-field">Magnetic field</a><a id="Magnetic-field-1"></a><a class="docs-heading-anchor-permalink" href="#Magnetic-field" title="Permalink"></a></h2><p>The next thing we need is a magnetic field function. This can by any callable object, so long as it takes in an axial location in meters and returns a magnetic field strength in Teslas. Let&#39;s use a magnetic field with a Gaussian shape and a peak radial magnetic field strength of 200 Gauss at the channel exit plane:</p><pre><code class="language-julia hljs">function my_magnetic_field(z)
    if z &lt; 0.03
        return 0.02 * exp(-((z - 0.03) / 0.02)^2)
    else
        return 0.02 * exp(-((z - 0.03) / 0.04)^2)
    end
end</code></pre><p>Alternatively, we may want to load in a magnetic field from a file. Suppose we have a magnetic field stored in a file <code>my_bfield.csv</code> which has the following first few lines:</p><pre><code class="language-csv hljs">z(m),Br(T)
0.0,0.0021079844912372868
0.001,0.0024430133907998
0.002,0.0028171684184209005
0.003,0.0032324238493067863
0.004,0.003690390479859787
0.005,0.004192227743021959
0.006,0.004738555173642436
0.007,0.005329365956270483
0.008,0.005963945588597749
0.009,0.006640798906893217
0.01,0.00735758882342885
...</code></pre><p>We could load this in using the <code>DelimitedFiles</code> package</p><pre><code class="language-julia hljs">my_magnetic_field_data, header = readdlm(&quot;my_bfield.csv&quot;, &#39;,&#39;, header=true)</code></pre><p>We can then construct a function which interpolates the data (here a linear interpolation, but you can use more complex interpolations using the <a href="https://github.com/JuliaMath/Interpolations.jl"><code>Interpolations.jl</code></a> package):</p><pre><code class="language-julia hljs">z_data = my_magnetic_field_data[:, 1]
Br_data = my_magnetic_field_data[:, 2]
my_magnetic_field_itp = HallThruster.LinearInterpolation(z_data, Br_data)</code></pre><h2 id="Creating-a-Thruster"><a class="docs-heading-anchor" href="#Creating-a-Thruster">Creating a Thruster</a><a id="Creating-a-Thruster-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Thruster" title="Permalink"></a></h2><p>Once we have a geometry and a magnetic field, we can construct a <code>Thruster</code>:</p><pre><code class="language-julia hljs">my_thruster = HallThruster.Thruster(
	name = &quot;My thruster&quot;,
    magnetic_field = my_magnetic_field,
    geometry = my_geometry,
    shielded = false,
)</code></pre><p>In addition to a magnetic field and a geometry, we have also provided a name (optional) and designated whether the thruster is magnetically shielded or not. If <code>true</code>, then the electron temperature used for electron wall loss computations will be the anode temperature instead of the temperature on centerline.</p><h2 id="Defining-a-Config"><a class="docs-heading-anchor" href="#Defining-a-Config">Defining a Config</a><a id="Defining-a-Config-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-Config" title="Permalink"></a></h2><p>We can now define a <code>Config</code>. We will run a simulation using Xenon propellant and two ion charge states, with a discharge voltage of 300 V and a mass flow rate of 6 mg/s. For anomalous transport, we use a multi-zone Bohm-like transport model. Many more options than these can be tweaked.  For more information and a list all possible options, see the <a href="../config/#Configuration">Configuration</a> page.</p><pre><code class="language-julia hljs">my_config = HallThruster.Config(
    ncharge = 2,
    discharge_voltage = 300u&quot;V&quot;,
    thruster = my_thruster,
    domain = (0.0u&quot;cm&quot;, 8.0u&quot;cm&quot;),
    anode_mass_flow_rate = 8.0u&quot;mg/s&quot;,
    wall_loss_model = HallThruster.WallSheath(HallThruster.BoronNitride),
    anom_model = HallThruster.MultiLogBohm([0.02, 0.03, 0.04, 0.06, 0.006, 0.2]),
    propellant = Xenon,
    neutral_velocity = 500.0u&quot;m/s&quot;,
    neutral_temperature = 500.0u&quot;K&quot;,
    ion_temperature = 500.0u&quot;K&quot;,
    cathode_Te = 2.5u&quot;eV&quot;,
    anode_Te = 2.5u&quot;eV&quot;,
    ion_wall_losses = true,
)</code></pre><h2 id="Running-a-simulation"><a class="docs-heading-anchor" href="#Running-a-simulation">Running a simulation</a><a id="Running-a-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Running-a-simulation" title="Permalink"></a></h2><p>Now we can run a simulation. To do this, we use the <code>run_simulation</code> function. In addition to the <code>Config</code> object we just created, we also pass in how many cells we want to run the simulation with, the number of frames we want to save, the timestep, in seconds and the simulation duration (also in seconds).</p><pre><code class="language-julia hljs">julia&gt; @time my_solution = HallThruster.run_simulation(my_config; ncells=150, nsave=10000, dt=1e-8, duration=1e-3)
 36.058672 seconds (783.66 k allocations: 519.964 MiB)
Hall thruster solution with 10000 saved frames
Retcode: success
End time: 0.001 seconds</code></pre><h2 id="Postprocessing-and-analysis"><a class="docs-heading-anchor" href="#Postprocessing-and-analysis">Postprocessing and analysis</a><a id="Postprocessing-and-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing-and-analysis" title="Permalink"></a></h2><p>Once you have run a Hall thruster simulation, you will want to analyze the results to see how your simulation performed. This section describes the utilities available for such tasks.</p><h3 id="The-Solution-object"><a class="docs-heading-anchor" href="#The-Solution-object">The <code>Solution</code> object</a><a id="The-Solution-object-1"></a><a class="docs-heading-anchor-permalink" href="#The-Solution-object" title="Permalink"></a></h3><p>Running a simulation returns a <code>HallThruster.Solution</code> object. This mimics a DifferentialEquations <code>DiffEqSolution</code> object and has the same fields:</p><p><code>t</code>: A <code>vector</code> of times at which the simulation state is saved <code>u</code>: A <code>vector</code> of simulation state matrices saved at each of the times in <code>t</code> <code>savevals</code>: A <code>Vector</code> of <code>NamedTuple</code>s containing saved derived plasma properties at each of the times in <code>t</code> <code>retcode</code>: A <code>Symbol</code> describing how the simulation finished. This should be <code>:Success</code> if the simulation succeeded, but may be <code>:NaNDetected</code> if the simulation failed. <code>params</code>: A NamedTuple containing simulation parameters, such as the <code>Config</code> the simulation was run with, the computational grid, and more.</p><h3 id="Extracting-performance-metrics"><a class="docs-heading-anchor" href="#Extracting-performance-metrics">Extracting performance metrics</a><a id="Extracting-performance-metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-performance-metrics" title="Permalink"></a></h3><p>After running a simulation, the two things we might care the most about are the predicted thrust and discharge current. These can be computed with the <code>thrust</code> and <code>discharge_current</code> functions, respectively.</p><pre><code class="language-julia hljs">julia&gt; HallThruster.thrust(my_solution) # Thrust in Newtons at every saved frame
10000-element Vector{Float64}:
 0.24759825170838257
 0.23553180163085566
 ⋮
 0.1677545384599781
 0.1677545384591017

julia&gt; HallThruster.thrust(my_solution, 12) # Thrust in Newtons at the twelfth frame
0.16887856098607704</code></pre><pre><code class="language-julia hljs">julia&gt; HallThruster.discharge_current(my_solution) # Discharge current in A at every frame
10000-element Vector{Float64}:
 16.594260447976414
 16.491449186956455
  ⋮
 12.635410795570154
 12.63541079552306

julia&gt; HallThruster.discharge_current(my_solution, 1999) # Discharge current in A at the 1999th frame
12.137864749597252
</code></pre><p>We can plot the ion, electron, and total currents using our plotting package of choice. In this case, we use Plots</p><pre><code class="language-julia hljs">using Plots
time_us = my_solution.t .* 1_000_000 # Convert time from seconds to microseconds
I_ion = ion_current(my_solution)
I_total = discharge_current(my_solution)
I_electron = I_total .- I_ion # we can also just type electron_current(my_solution)

p = plot(
    time_us, I_ion;
    label = &quot;Ion current&quot;,
    xlabel = &quot;Time (microseconds)&quot;,
	ylabel = &quot;Current (A)&quot;
)
plot!(p, time_us, I_electron; label = &quot;Electron current&quot;)
plot!(p, time_us, I_total; label = &quot;Discharge current&quot;, linewidth = 2)

display(p)
</code></pre><p><img src="https://raw.githubusercontent.com/UM-PEPL/HallThruster.jl/main/docs/src/assets/current_example.png" alt/></p><h3 id="Time-averaging-results"><a class="docs-heading-anchor" href="#Time-averaging-results">Time averaging results</a><a id="Time-averaging-results-1"></a><a class="docs-heading-anchor-permalink" href="#Time-averaging-results" title="Permalink"></a></h3><p>In the above case, the simulation settled to a steady state after 250 microseconds, so we could just look at the last frame to obtain our performance and plasma properties. However, Hall thrusters are often oscillatory. To see this, let&#39;s cut the minimum anomalous collision frequency in half and re-run the simulation. The new config is:</p><pre><code class="language-julia hljs">my_config = HallThruster.Config(
    ncharge = 2,
    discharge_voltage = 300u&quot;V&quot;,
    thruster = my_thruster,
    domain = (0.0u&quot;cm&quot;, 8.0u&quot;cm&quot;),
    anode_mass_flow_rate = 8u&quot;mg/s&quot;,
    wall_loss_model = HallThruster.WallSheath(HallThruster.BoronNitride),
    # change second to last number here from 0.006 to 0.003
    anom_model = HallThruster.MultiLogBohm([0.02, 0.03, 0.04, 0.06, 0.003, 0.2]),
    propellant = Xenon,
    neutral_velocity = 500.0u&quot;m/s&quot;,
    neutral_temperature = 500.0u&quot;K&quot;,
    ion_temperature = 500.0u&quot;K&quot;,
    cathode_Te = 2.5u&quot;eV&quot;,
    anode_Te = 2.5u&quot;eV&quot;,
    ion_wall_losses = true,
)</code></pre><p>Plotting the current, we find that the solution now no longer converges to a steady value but instead oscillates strongly about a mean:</p><p><img src="https://raw.githubusercontent.com/UM-PEPL/HallThruster.jl/main/docs/src/assets/current_example_2.png" alt/></p><p>To compute performance, we want to average over several of the oscillations. To do this, we employ the <code>time_average</code> function</p><pre><code class="language-julia hljs">julia&gt; my_time_average = time_average(my_solution)
Hall thruster solution with 1 saved frames
Retcode: Success
End time: 0.001 seconds</code></pre><p>The <code>time_average</code> function returns another <code>Solution</code> object, just like <code>my_solution</code>, with a single saved frame holding the time-averaged simulation data. In the case of our oscillatory simulation above, the simulation doesn&#39;t settle into a stationary mode until about 100 microseconds have elapsed (about 1000 frames, since we saved 10000 total). If we want to only average the last 9000 frames, we would type</p><pre><code class="language-julia hljs">julia&gt; my_time_average = time_average(my_solution, 1000) # start averaging at frame 1000</code></pre><h3 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h3><p><code>HallThruster.jl</code> includes plotting recipes to allow you to plot your simulation results if the <code>Plots</code> package is installed. To plot the last frame of the simulation, you can type:</p><pre><code class="language-julia hljs">using Plots

plot(my_solution)</code></pre><p><img src="https://raw.githubusercontent.com/UM-PEPL/HallThruster.jl/main/docs/src/assets/plot_example.png" alt/></p><p>To plot a different frame, you can do <code>plot(my_solution, frame_you_want)</code>. You can also plot time averaged solutions, as they are no different from a standard solution. You can also plot certain parts on a log scale using the <code>yaxis=:log</code> argument, add labels using <code>label = &quot;label&quot;</code>, and plot solutions over each other using <code>plot!</code>, just as normal using Plots.jl.</p><h3 id="Computing-efficiencies"><a class="docs-heading-anchor" href="#Computing-efficiencies">Computing efficiencies</a><a id="Computing-efficiencies-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-efficiencies" title="Permalink"></a></h3><p>There are several key efficiency metrics that are employed to judge how well a Hall thruster performs. The most common is the anode efficiency, defined as the ratio of thrust power to power put into the plasma:</p><p class="math-container">\[\eta_a = \frac{1}{2}\frac{T^2}{\dot{m} V_d I_d}\]</p><p>We can compute this using the <code>compute_anode_eff</code> function, which returns the anode efficiency at every timestep:</p><pre><code class="language-julia hljs">julia&gt; HallThruster.anode_eff(my_solution)
10000-element Vector{Float64}:
 0.769654845938557
 0.7008079984180736
 ⋮
 0.46399997114634145
 0.46399997114322283</code></pre><div class="admonition is-warning"><header class="admonition-header">Computing average efficiencies</header><div class="admonition-body"><p>When computing time-averaged efficiencies, it is better to first time-average the simulation and then compute the efficiencies    from the averaged plasma properties then it is to average the instantaneous efficiencies. For example,</p><pre><code class="language-julia hljs">avg_eff = mean(HallThruster.anode_eff(my_solution))  # not ideal
avg_eff = HallThruster.anode_eff(time_average(my_solution)[] # better</code></pre></div></div><p>The mass utilization efficiency is the ratio of the ion beam mass flow rate to the total anode input mass flow rate and is computed with <code>compute_mass_eff</code>:</p><pre><code class="language-julia hljs">julia&gt; HallThruster.mass_eff(my_solution)
10000-element Vector{Float64}:
 1.3406882897286088
 1.2966376960524595
 ⋮
 1.0022667540786294
 1.0022667540739632</code></pre><p>The current utilization efficiency is the ratio of the ion current to the discharge current:</p><pre><code class="language-julia hljs">julia&gt; HallThruster.current_eff(my_solution)
10000-element Vector{Float64}:
 0.599052550532874
 0.58182111692138
 ⋮
 0.552664262832069
 0.5526642628312223</code></pre><p>The voltage utilization efficiency is the ratio of the effective acceleration voltage to the discharge voltage:</p><pre><code class="language-julia hljs">julia&gt; HallThruster.voltage_eff(my_solution)
10000-element Vector{Float64}:
 0.9962185160007747
 0.9699301625865606
 ⋮
 0.8856545575551746
 0.8856545575546175</code></pre><h3 id="Extracting-plasma-properties"><a class="docs-heading-anchor" href="#Extracting-plasma-properties">Extracting plasma properties</a><a id="Extracting-plasma-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-plasma-properties" title="Permalink"></a></h3><p>To access a plasma property, you index the solution by the symbol corresponding to that property. For example, to get the plasma density at every frame, I would type:</p><pre><code class="language-julia hljs">julia&gt; ne = my_solution[:ne]
10000-element Vector{Vector{Float64}}:
...</code></pre><p>This returns a <code>Vector</code> of <code>Vectors</code> containing the number density at every frame and every cell. To get the number density just in the 325th frame, I would type</p><pre><code class="language-julia hljs">julia&gt; ne_end = my_solution[:ne][325]
152-element Vector{Float64}:
 9.638776090165182e16
 9.638776090165182e16
 1.1364174787296864e17
 ⋮
 2.568578735293536e17
 2.532630941584664e17
 2.532630941584664e17</code></pre><p>This has 152 elements, one for each of the 150 interior cells and 2 for the left and right boundary. To get the axial locations of these cells in meters, we can access <code>sol.params.z_cell</code>.</p><p>For ion parameters (ion density and velocity), we  specify which charge state we want to extract. For example, to get the velocity (in m/s) of doubly-charged Xenon at the 4900th frame, we would type:</p><pre><code class="language-julia hljs">julia&gt; ui = my_solution[:ui, 2][4900]
152-element Vector{Float64}:
 -1795.4362688519843
 -1724.298256534735
 -1647.858433966283
     ⋮
 27654.42396859592
 27735.77112807524
 27735.756446024698</code></pre><p>Here, indexing by <code>[:ui, 2]</code> means we want the velocity for doubly-charged ions. We could similarly index by <code>[:ni, 1]</code> for the density of singly-charged ions.</p><p>The parameters that support this sort of indexing are:</p><ul><li><code>B</code>: Magnetic field strength in Tesla</li><li><code>ωce</code>: Cyclotron frequency in Hz</li><li><code>νan</code>: Anomalous collision frequency in Hz</li><li><code>νe</code>: Total electron collision frequency in Hz</li><li><code>νc</code>: Classical collision frequency in Hz</li><li><code>νei</code>: Electron-ion collision frequency in Hz</li><li><code>νen</code>: Electron-neutral collision frequency in Hz</li><li><code>νex</code>: Excitation collision frequency in Hz</li><li><code>νiz</code>: Ionization collision frequency in Hz</li><li><code>νew</code>: Electron-wall collision frequency in Hz</li><li><code>μ</code>: Electron mobility</li><li><code>E</code>: Electric field</li><li><code>ϕ</code>: plasma potential at cell centers in V</li><li><code>Tev</code>: Electron temperature in eV</li><li><code>pe</code>: Electron pressure in eV/m^3</li><li><code>∇pe</code>: Electron pressure gradient</li><li><code>nn</code>: Neutral density</li><li><code>ni</code>: Ion density (default 1st charge state, index by <code>[:ni, Z]</code> to get charge state <code>Z</code>)</li><li><code>ui</code>: Ion velocity (default 1st charge state, index by <code>[:ui, Z]</code> to get charge state <code>Z</code>)</li></ul><h3 id="Saving-simulations-for-use-as-restarts"><a class="docs-heading-anchor" href="#Saving-simulations-for-use-as-restarts">Saving simulations for use as restarts</a><a id="Saving-simulations-for-use-as-restarts-1"></a><a class="docs-heading-anchor-permalink" href="#Saving-simulations-for-use-as-restarts" title="Permalink"></a></h3><p>To save a simulation for later, you can use the <code>write_restart</code> function. We can then read it back with the <code>read_restart</code> function:</p><pre><code class="language-julia hljs">julia&gt; HallThruster.write_restart(&quot;my_restart.jld2&quot;, my_solution);

julia&gt; HallThruster.read_restart(&quot;my_restart.jld2&quot;)
Hall thruster solution with 10000 saved frames
Retcode: Success
End time: 0.001 seconds</code></pre><p>To use a restart as the initial condition for a simulation, you can use the <code>restart</code> keyword argument in the <code>run_simulation</code> function:</p><pre><code class="language-julia hljs">julia&gt; @time my_solution = HallThruster.run_simulation(my_config; ncells=150, nsave=10000, dt=1e-8, duration=1e-3, restart = &quot;my_restart.jld2&quot;)
 34.700016 seconds (7.27 M allocations: 1016.374 MiB, 0.79% gc time, 5.42% compilation time)
Hall thruster solution with 10000 saved frames
Retcode: Success
End time: 0.001 seconds</code></pre><p>If we plot the currents, we see that the simulation remained at the steady state established in the initial run:</p><p><img src="https://raw.githubusercontent.com/UM-PEPL/HallThruster.jl/main/docs/src/assets/current_restart.png" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorial/">Tutorial notebook »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 4 July 2023 18:42">Tuesday 4 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
